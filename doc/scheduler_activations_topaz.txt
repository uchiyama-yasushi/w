scheduler activations: effective kernel support for the user-level
management of parallelism

thomas e.anderson, brian n.bershad, edward d.lazowska and henry m.levy
university of washington

acm transactions on computersystems, vol.10, no.1, february 1992,p53-79.

スレッドは多くの並行プログラミングにおいて、並行性の手段である。スレッ
ドはOSカーネルでも、ユーザ層のライブラリでも提供され得るが、どちらのア
プローチも完全に満足いくものではない。この論文ではこの板狭みに取り組む。
最初に、既存の実装の問題でなく、ユーザスレッドに比較してカーネルスレッ
ドの性能は本質的に悪いことを示す。次に、ユーザスレッドを他のシステムサー
ビスと統合する際に遭遇する問題は、マルチプロセッサOSのユーザスレッドの
ためのカーネルサポートが不足していることにある。ユーザスレッドの管理を
するのにカーネルスレッドは悪い抽象化である。最後に、ユーザ層で管理する
ことの柔軟性と性能を妥協することない新しいカーネルインターフェースとユー
ザスレッドパッケージの設計、実装、その性能について述べる。

1. 導入

並行コンピューティングの効果はプログラムでその並行性を表現し、制御する
プリミティブの性能の程度にかなり依存する。粗粒度の並行プログラムでさえ、
並行さを作成し、管理するコストが高ければ、悪い性能になる。細粒度の並行
プログラムでも、並行さを作成し、管理するコストが低ければ高性能を達成で
きる。

並行プログラムを作成する一つの方法は、伝統的なunix的なプロセスの間でメ
モリを共有することで、それぞれはそのアドレス空間と、そのアドレス空間で
実行されれる単一の実行環境である。あいにくそれらのプロセスは単一プロセッ
サ上での並行プログラムとして設計されたもののため、一般的な並行プログラ
ムには単純で、とても不適切である。

伝統的なプロセスは一般的な並行プログラムには不適切であり、スレッドを使
うことになった。スレッドはアドレス空間や、I/O記述子のような伝統的なプロ
セスにある要素から実行環境を分離する。この関連性を分離することによって
伝統的なプロセスに較べて実行時性能を大幅に改善できる。

1.1 問題

スレッドはユーザ層でもカーネル層でも実装できる。そのどちらも完全に満足
できるものではない。ユーザ層スレッドはそれぞれのアプリケーションにリン
クされた実行時ライブラリによって制御され、スレッド管理にはカーネルの介
入はない。結果としてよい性能になる: pcr[25]とfastthreads[2]のように、ユー
ザ層のスレッドの操作は関数呼出し程度の負荷で済む。ユーザ層スレッドはさ
らに柔軟であり、カーネルの変更なしに、使い手や言語の要求に応じて作るこ
とができる。

ユーザ層のスレッドは伝統的なプロセスの環境で実行される。実際、ユーザ層
スレッドシステムは、一般にOSカーネルの変更なしに構築されている。スレッ
ドシステムはそれぞれのプロセスをプロセスを「仮想プロセッサ」とみなして
いて、その制御下で実行される物理プロセッサとして扱う。それぞれの仮想プ
ロセッサはユーザ層のコードを実行リストからとってきて実行する。実際には
これらの仮想プロセッサはカーネルによって物理プロセッサに多重化されてい
る。並行プログラム、I/O、ページフォルトに対する「現実の」OSの動きは仮想
と現実のプロセッサの同一性を歪めてしまう。これらの要素があるために、伝
統的なプロセスの上に構築されたユーザ層スレッドは性能が出なかったり、間
違った振舞いをしてしまうことがある。

mach[21]、topaz[22]、v[7]のようなマルチプロセッサOSはアドレス空間毎のス
レッドをカーネルで直接提供している。カーネルスレッドを使ってプログラム
することで、ユーザ層スレッドによって問題となったシステムの整合性の問題
を回避できる。カーネルはそれぞれのアプリケーションのスレッドを物理プロ
セッサに直接スケジュールするからである。あいにくカーネルスレッドは伝統
的なunixプロセスと同じように多くの並行プログラムにとって、あまりにも重
い。カーネルスレッドの性能は一般に一桁程度伝統的なプロセスよりも良いが、
ユーザスレッドの良い事例(つまり、並行処理とI/Oがない)の性能に較べて一桁
悪い。結果として、mach(cthreads[8])とtopaz(workcrews[24])のユーザ層のス
レッドはついにカーネルスレッドの上に実装されることになった。ユーザ層の
スレッドは伝統的なプロセスの上に構築されるのとまったく同じようにカーネ
ルスレッドの上に構築される; それらはちょうど同じような性能であり、同じ
問題を抱える。

並行プログラマはそして難しい板狭みに直面することになった: 単一プログラ
ムでI/Oがないアプリケーションには良い性能と正しい振舞いをするユーザ層ス
レッドを使うか、性能は悪いがそのような制限のないカーネルスレッドを使う
かだ。

1.2 この研究の目標

この論文ではこの板挟みに取り組む。カーネルスレッドの機能とユーザ層スレッ
ドの柔軟性と性能を組み合わせたカーネルインターフェースとユーザ層のスレッ
ドパッケージを述べる

具体的には、

 - スレッドの操作にカーネルの仲介が必要ない一般的な事例では、一番良い出
   来のユー ザ層スレッド管理システム(これはシステムによく統合されていな
   いという問題があるが)との性能と本質的に同じである。

 - プロセッサの再割当てや、I/Oのようなカーネルの介入が必要となる、まれ
   な場合では、カーネルスレッド管理システムの振舞いをまねることができる:

   - 準備完了なスレッドがある場合にはプロセッサが待機することがない。
   - 高優先度のスレッドが低優先度のスレッドの走行の間、待つことはない。
   - スレッドがカーネルにトラップされてブロックする時(例えばページフォ
     ルトにより)、そのスレッドに使われていたプロセッサは他のスレッド(ア
     ドレス空間を問わない)に使うことができる。

 - 我々のシステムのユーザ層の部分はアプリケーション固有な注文を簡単にす
   るように構成されている。スケジューリング方針を変更するのも簡単である
   し、workers[16],actors[1],futures[10]のような、異る並行モデルさえも
   用意できる。

これらの目標をマルチプロセッサ上の並行プログラムで達成する難しさは、必
要な制御やスケジューリングの情報をカーネルとそれぞれのアプリケーション
のアドレス空間に分配されるということである。アプリケーションの間にプロ
セッサを割当てることを可能にするために、カーネルはユーザ層のスケジュー
リングの情報が必要である(つまりそれぞれのアドレス空間は、どの程度の並行
度があるか)。アプリケーションの並行性を管理するために、ユーザ層のスレッ
ドシステムは、プロセッサ再割当てや、I/O要求、終了のような、普通アプリケー
ションには隠されているカーネルの事象について知っている必要がある。

1.3 やり方

我々のやり方では、それぞれのアプリケーションに仮想マルチプロセッサを提
供する。専用の物理マシンの抽象化である。それぞれのアプリケーションはい
くつの(どこの)プロセッサが割当てられたかを正確に知っていて、そのスレッ
ドのどれがこれらのプロセッサで走行するかについて完全に制御する。OSカー
ネルはアドレス空間の間でプロセッサの割当てを完全に制御し、それには
アプリケーションの実行中にプロセッサの割当ての数を変更することも含む。

これらを達成するために、カーネルは、そのアドレス空間のスレッドスケジュー
ラにそのアドレス空間に影響するあらゆるカーネルの事象を通知し、アプリケー
ションにそのスケージューリング状態について完全な情報を与える。それぞれ
のアドレス空間のスレッドシステムはカーネルに、プロセッサ割当ての決定に
影響を与えるユーザ層のスレッド操作を通知し、カーネルに反映する必要のな
い大部分のスレッド操作の性能は良いままである。

これらの考えを実現するに使ったカーネルの機構を「スケジューラアクティベー
ション」と呼んだ。スケジューラアクティベーションはカーネルイベントによ
る制御をカーネルからアドレス空間スレッドスケジューラに移行する。そのス
レッドスケジューラはそのアクティベーションをユーザ層のデータ構造を変更
したり、ユーザ層のスレッドを実行したり、カーネルへの要求を作成したりす
るのに使うことができる。

この設計の試作はdec srcのfireflyマルチプロセッサワークステーション[22]
によってなされた。スケジューラアクティベーションとカーネルスレッドの違
いは大きいものの、類似点も十分にあるので、カーネル側の実装はtopazのカー
ネルスレッドへの比較的卒直な改造で済んだ。topazはfirefly由来のOSである。
同じように、ユーザ層への実装は、比較的卒直なfast threads(これはtopazの
カーネルスレッドの上に構築されるように設計されたユーザ層スレッドシステ
ムである)への改造で済んだ。

我々の目標は、カーネルスレッドの機能を正確にユーザ層で用意できることを
示すことであるため、この論文での発表は、ユーザ層のスレッドはプログラマ
あるいはコンパイラによって使われている並行性モデルであることと仮定する。

他の並行性モデルで、それがカーネルスレッドあるいはプロセスの上に構築さ
れたユーザ層であり、ユーザ層スレッドと同じような問題があるのであれば、
それらをスケジューラアクティベーションの上に構築することで問題は解決さ
れる。

2. ユーザ層スレッド: 性能的な優位さと、機能の制限

この章では、我々の研究の動機は、ユーザ層スレッドがカーネルスレッドに較
べて優位であること、ユーザ層スレッドをカーネルスレッドやプロセスの上に
構築することによる困難さである。ユーザ層スレッドの性能は、実装上の問題
ではなく、本質的にカーネルスレッドより良いことを示す。ユーザ層スレッド
は、さらにプログラミングモデルや実行環境に対して柔軟性ががある。その上、
ユーザ層スレッドによって明らかになったシステムの問題はユーザ層スレッドに
起因するものではなく、不適切なカーネル支援によるものであることを示す。

2.1 ユーザ層スレッド管理

ユーザ層スレッドにある最適化がカーネルにも適用でき、それが機能の妥協な
くユーザ層スレッドと同じように効果があると考えるのは自然である。あいに
くカーネル内のスレッドを管理するには本質的にとても高くつくものがある:

 - スレッド管理の操作の費用: カーネルスレッドではプログラムは全てのスレッ
   ド操作で、余分の保護境界をまたがないといけない。同じアドレス空間でス
   レッドをスイッチする時であってもだ。これは余計なカーネルトラップだけ
   でなく、引数をコピーして、それを検査しなくてはならない。カーネルはバ
   グっていたり、悪意のあるプログラムから守らないといけないからだ。対照
   的にユーザ層スレッドの操作はまったく楽に処理することができて、コンパ
   イラがコードをインライン展開し、洗練されたレジスタ割当てをすると、と
   りわけ良い。その上、安全性は妥協できる: アドレス空間の境界があるので
   ユーザ層スレッドシステムの間違った使用があったとしても、問題ない。

 - 一般化の費用: カーネルスレッド管理では、一つの実装を全てのアプリケー
   ションが使用する。一般的にするために、カーネルスレッドシステムは、妥
   当なアプリケーションで必要となる全ての機能を提供しないといけない; こ
   れは特定の機能を必要としないアプリケーションにとっては余計な費用とな
   る。対照的にユーザ層スレッドはアプリケーションによって別のスレッドラ
   イブラリをリンクすることができるので、そのアプリケーションの必要なだ
   けのシステムを提供することができる。例えば、多くの並行アプリケーショ
   ンが単純なfifoのようなスケジューリング[24]を使うことができるのに、多
   くのカーネルスレッドシステムは優先度横取りスケジューリングを実装して
   いる

これらの要因はスレッド管理の操作が本質的に重いものであれば重要でなかっ
ただろう。カーネルへのトラップや優先度スケジューリングの費用は、例えば
unixのプロセスのような大きな費用のかかる場合では大きな問題ではなかった。
しかしながら、スレッド操作の費用は関数呼出しの費用になり得る。なのでカー
ネル実装によって追加されるいかなる費用も、例え少なくともそれは多大であ
り、良い実装のユーザ層スレッドシステムは、良い実装のカーネルスレッドシ
ステムよりずっとよい性能となる。

 この量を明らかにするために、表1ではユーザ層スレッド、カーネルスレッド、
unix風プロセスの例としての実装の性能を示している。これらは全て同じcvax
プロセッサの上で動かしている。fastthreadsとtopazのカーネルスレッドは
cvax firefly上で計測し、ultrix(decのunix派生物)はcvaxの単一プロセッサの
ワークステーション上で計測した。(これらの実装のそれぞれは良いが最適では
ない。なのでこの測定は例であって、絶対ではない)

 二つのベンチマークは「null fork」で、何もしない手続きのスレッド/プロセ
スを生成し、スケジュールし、実行し、完結する時間(スレッドをforkするオー
バーヘッド)を計るものと、「signal wait」待ち状態のプロセス/スレッドにシ
グナルを送り、その状態を待つ時間(二つのスレッドを同期させるオーバーヘッ
ド)である。それぞれのベンチマークは単一プロセッサ上で実行し、結果は多数
反復した結果の平均である。比較のために、関数呼び出しはfireflyで7usec、
カーネルトラップは19usecかかる。

表 1 スレッド操作待ち時間(usec)
操作		fastthreads	topaz threads	ultrix processes
null fork	34		948		11300
signal-wait	37		441		1840

表1は、ultrixのプロセス管理とtopazのスレッド管理の間には一桁の違いがあ
るが、さらにtopazスレッドとfastthreadsの間には桁で違いがあることを示し
ている。topazスレッドのコードは多くの重要な部分はアセンブラによって書か
れ、高度に最適化されていているにもかかわらずだ。

一般に、システムサービスを実装するところで、柔軟性と性能の間でトレード
オフが生じる[26]。しかしながらユーザ層スレッドにはこのトレードオフがな
い: 性能と柔軟性が同時に向上する。スレッドシステムにおいて柔軟性はとり
わけ重要で、多くの並行プログラミングが存在し、それらはスレッドシステム
による特別な支援が必要かもしれないからだ。カーネルスレッドで、複数の並
行プログラミングモデルの支援をしようとすると、カーネルの変更が必要であ
り、それによって複雑さ、オーバーヘッドが増し、そしてカーネル内に問題が
起きがちである。

2.2 伝統的なカーネルインターフェースの上に構築されたユーザ層スレッドの
統合性の悪さの原因

カーネルスレッドとして提供されるサービスと同等のものをユーザ層スレッド
に実装することは難しいことが残念ながら明らかになった。これはユーザ層で
並行性を管理することに起因するのではなく、現存のシステムのカーネル支援
の不足の結果である。カーネルスレッドはユーザ層のスレッド管理には悪い抽
象化である。二つの関連したカーネルスレッドの性質によって困難さが生じる。

 - カーネルスレッドはユーザ層への通知なしに、ブロックし再開し、横取りさ
   れる。

 - カーネルスレッドはユーザ層のスレッドの状態に関係なくスケジュールされ
   る。

 これらによって、単一プログラムであっても問題を生じる。ユーザ層スレッド
システムは、しばしば多くのカーネルスレッドを「仮想プロセッサ」としてシ
ステムにある物理プロセッサの数だけ作成するだろう: それぞれでユーザ層の
スレッドが走るだろう。ユーザ層のスレッドがブロックI/Oをしたり、ページフォ
ルトをした時、その仮想プロセッサとして供されているカーネルスレッドもブ
ロックする。結果として、I/O待ちの間、物理プロセッサはアドレス空間に失な
われてしまう。なぜなら、他のユーザ層スレッドで走るカーネルスレッドがな
いからだ。そこだけ待機しているプロセッサで他のユーザスレッドを走らせる
カーネルスレッドがないからだ。

これに対するもっともらしい解決は物理プロセッサの数以上のカーネルスレッ
ドを作成することだろう; あるカーネルスレッドのユーザ層スレッドがカーネ
ル内でブロックした時、他のカーネルスレッドがそのプロセッサでユーザ層ス
レッドを走らせることができる。しかしながら、I/O処理が終了したりページフォ
ルトから帰ってきた時に難しさが生じる:プロセッサの数より多くの走行できる
カーネルスレッドが必要になるだろう。それぞれのカーネルスレッドはユーザ
層を走行している最中である。どのカーネルスレッドをプロセッサに割当てる
か決定することにおいて、OSは暗黙的にどのユーザ層スレッドをプロセッサに
割当てるかを選択している。

伝統的なシステムでは、プロセッサより多くの走行可能なスレッドがある場合、
それぞれのスレッドが進行することを保証するために、いろいろな種類の時分
割の手法を用いることができた。しかしながら、カーネルスレッドの上でユー
ザスレッドが走っている場合、時分割は問題を起こすことになる。例えば、ユー
ザ層のスレッドがスピンロックしている間にそのカーネルスレッドは横取りさ
れ得る;そのロックを取ろうとするユーサ層スレッドは、ロックを保持している
スレッドが再走行するまでスピン待ちするだろう。zahorjanら[28]はスピンロッ
クがある場合の時分割が悪い性能になることを示した。他の例として、ユーザ
層のスレッドを走行しているカーネルスレッドは、他のカーネルスレッド、そ
れはユーザ層のスケジューラで待機状態になっているものに、横取りされるこ
とがある。あるいは、ユーザ層で高優先度のスレッドを走行しているカーネル
スレッドは、ユーザ層で低優先度で走行しているカーネルスレッドに横取りさ
れ得る。

 まったく同じ問題が、I/Oやページフォルトの起こる並行プログラミングにお
いて起こる。システムに一つのジョブしかないのであれば、全てのプロセッサ
を使うことができる; 他のジョブが投入された場合、OSは最初のジョブのプロ
セッサを横取りして、新しいジョブに割当てるべきだ[23]。カーネルは最初の
ジョブのカーネルスレッドのどれかを選ばないといけなく、そのユーザ層スレッ
ドは残りのプロセッサで走行することになる。ジョブ内での並行性の変化によっ
てもアドレス空間からプロセッサを横取りする必要がでてくる; zahorjanと
mccann[27]は、高性能にするには、並行性の変化に応答するためにアドレス空
間の間で動的にプロセッサを割当てることが重要なことを示した。

カーネルスレッドのスケジューリングをユーザ層に反映するカーネルインター
フェースを実装することは可能だが[5]、この情報はユーザ層スレッドと深く関
わる； カーネルとユーザ層の間でこの情報をやりとりすることによって、ユー
ザ層スレッドを使うの利点である、性能や柔軟性の多くをだいなしにしてしま
う。

結局、カーネルスレッド上に構築されたユーザスレッドの論理的に正しい動き
を保証することは難しい。多くのアプリケーション、とりわけアドレス空間を
またいだ整合性が必要なものは、全ての走行可能なスレッドは最終的には必ず
プロセッサ時間を得れるという前提のもとにデッドロックを回避している。ア
プリケーションがカーネルスレッドを直接使用した時は、カーネルの時分割に
よってこの前提は保証される。しかし、ユーザ層のスレッドが、固定された数
のカーネルスレッドに多重化された場合、この仮定はもはや保証されない。カー
ネルスレッドがそのユーザ層スレッドでブロックされた場合、他の走行可能な
ユーザ層スレッドや、使用可能なプロセッサがあったとしても、アプリケーショ
ンはその実行コンテキストとしてのカーネルスレッドを失ってしまうからだ。


3. ユーザ層の並行処理の管理に効果的なカーネル支援方法

2章では並行処理するのにカーネルスレッドを使った時の低性能と柔軟性のなさ
と、カーネルスレッドの上のユーザ層スレッドを使い、多重プログラムとI/Oが
存在した場合にまずい振舞いをする問題について述べた。これらの問題に取り
組むために、我々はカーネルスレッドの機能と、ユーザ層スレッドの性能と柔
軟性をとりあわせた新しいカーネルインターフェースとユーザ層スレッドシス
テムを設計した。

OSのカーネルはそれぞれのユーザ層スレッドシステムに、それが自分のものと
する仮想プロセッサを提供し、これは物理プロセッサの抽象化であるが、プロ
グラムの実行中にカーネルによってその数を変化される点が違う。この抽象化
にはいくつかの性質がある。

 - カーネルはプロセッサをアドレス空間に配分する; カーネルはそれぞれのア
   ドレス空間の仮想マルチプロセッサにどれだけのプロセッサを割当てるかを
   完全に制御する。

 - 各アドレススペースのユーザ層スレッドシステムは、それに配分されたプロ
   セッサでどのスレッドを走行させるかを完全に制御し、それはアプリケーショ
   ンが物理マシンの上で動いているかのように。

 - カーネルはユーザ層スレッドシステムに割当てるプロセッサの数を変更する
   時にはそれを通知する; カーネルはさらに、カーネルの中でユーザ層のスレッ
   ドがブロックしたり起床した時(I/Oや、ページフォルト等で)も通知する。
   カーネルの役割は事象を適切なスレッドスケジューラに誘導することで、そ
   れらを処理することではない。

 - ユーザ層スレッドシステムは、アプリケーションが必要とするプロセッサの
   数の増減が生じた時にそれをカーネルに通知する。カーネルはこの情報を元
   にそれぞれのアドレス空間に割当てるプロセッサの数を決める。ユーザ層ス
   レッドシステムはプロセッサの配分の決定にかかわりのある情報だけをカー
   ネルに通知する。これはユーザ層での操作の一部であるので性能はそう落ち
   ない。ほとんどのスレッド操作はカーネルとの通信のオーバーヘッドを受け
   ることがないからだ。

 - アプリケーションのプログラマは、直接カーネルスレッドを使ってプログラ
   ムするのと同じであり、性能だけが違う。我々のユーザ層スレッドシステム
   は、その仮想プロセッサをプログラマに透過的にし、通常のtopazスレッド
   [4]と同じインターフェースになる。(異なる並行プログラミングモデルであっ
   てもユーザ層の実行環境は簡単に適応することができる。)

この章の続きでは、どのようにしてカーネルの事象をユーザ層スレッドシステ
ムに誘導するかについて述べる。アプリケーションから提供されるどのような
情報によってカーネルはジョブ間でプロセッサの割当てをするのか、どのよう
にしてユーザ層のスピンロックを扱うのか。

3.1 カーネル事象をユーザ層スレッドスケジューラに誘導する詳細

カーネルのプロセッサ配分と、ユーザ層スレッドシステムの通信は「スケジュー
ラアクティベーション」によって構造化される。「スケジューラアクティベー
ション」という言葉は、それぞれの誘導された事象がユーザ層スレッドシステ
ムに、どのプロセッサでどのスレッドを走行させるかの計画の判定し直させる
ことになるということから選ばれた。

スケジューラアクティベーションは三つの役割を務める。

 - ユーザ層のスレッドが走行するための実行コンテキストになる。これはカー
   ネルスレッドがしていたこととまったく同じやり方である。

 - ユーザ層スレッドシステムにカーネル事象を通知する。

 - スレッドがカーネルによって停止された時(例えばI/Oや、カーネルがプロセッ
   サを横取りすることによって)、スケジューラアクティベーションの目下の
   ユーザ層スレッドのプロセッサコンテキストをカーネル内で退避しておく場
   所として。

スケジューラアクティベーションのデータ構造は伝統的なカーネルスレッドの
それとまったく似たようなものである。それぞれのスケジューラアクティベー
ションは二つの実行時スタックを持つ - 一つはカーネルに割当てられ、一つは
アプリケーションのアドレス空間に割当てられる。ユーザ層スレッドのそれぞ
れは、そのユーザ層のスタックを走行を開始する時に割当てられる[2]; ユーザ
層スレッドがカーネルの中に入ったら、そのスケジューラアクティベーション
のカーネルスタックを使う。ユーザ層スレッドシステムはスケジューラアクティ
ベーションのユーザ層のスタックで走る。加えて、カーネルはアクティベーショ
ン管理領域(スレッド管理領域に似たもの)を、そのスレッドがカーネル内でブ
ロックしたり横取りされた時に状態を保存しておき、ユーザ層スレッドスケ
ジューラはどのユーザ層スレッドがどのスケジューラアクティベーション上で
走行しているかの記録を保守する。

プログラムが開始されると、カーネルはスケジューラアクティベーションを作
成し、それにプロセッサを割当て、アプリケーションのアドレス空間の固定さ
れた入口にアップコールする。ユーザ層スレッド管理システムは、そのアップ
コールを受け、そのアクティベーションを実行コンテキストとして自分自身を
初期化し、アプリケーションスレッドを走行させる。最初のスレッドが実行さ
れ、さらにユーザスレッドを作成し、追加のプロセッサを要求するかもしれな
い。この場合、カーネルはそれぞれのプロセッサに対してスケジューラアクティ
ベーションを作成し、それを使ってユーザ層にアップコールし、新しいプロセッ
サが利用可能なことを通知するだろう。そしてユーザ層は、そのアクティベー
ションのコンテキストで走行するスレッドを選択し、実行させる。

同様に、カーネルが事象をユーザ層に通知する必要がある時には、カーネルは
スケジューラアクティベーションを作成し、それにプロセッサを割当て、アプ
リケーションのアドレス空間にアップコールする。一旦アップコールが開始さ
れるとアクティベーションは伝統的なカーネルスレッドと似たようなものであ
る。- それはプロセス事象を処理するのに使われ、ユーザ層スレッドで走行し、
カーネルにトラップされ、カーネルの中でブロックする。

スケジューラアクティベーションとカーネルスレッドの決定的な違いは、アク
ティベーションのユーザ層スレッドが一旦カーネルによって停止されると、そ
のスレッドがカーネルによって直接復帰することはは決してないことだ。その
かわりに、スレッドが停止した事をユーザ層に通知するための新しいアクティ
ベーションが作成される。そしてユーザ層スレッドシステムはそのスレッド状
態を以前のアクティベーションから削除し、以前のアクティベーションは再利
用可能であることをカーネルに通知し、最後にどのスレッドをプロセッサで実
行させるかを決定する。対照的に伝統的なシステムでは、カーネルスレッドを
カーネルが停止した時、それがそのコンテキストでユーザ層のスレッドが走っ
ていたとしても、その事を決してユーザ層には通知しない。しばらくして、カー
ネルスレッド(暗黙的にそのユーザスレッドも)は直接カーネルによって復帰す
るが、それも通知されることはない。スケジューラアクティベーションを使う
ことによってカーネルは、アドレス空間に割当てられたプロセッサの数と、走
行しているスケジューラアクティベーション(ユーザスレッドの容れ物)の数を
同じに維持していくことが可能になる。

表2にスケジューラアクティベーションによってカーネルからユーザ層に伝達さ
れる事象を一覧にした; それぞれのアップコールの引数は括弧で、ユーザ層ス
レッドシステムにによる動作は斜体。

----------------------------------------------------------------------
表2 スケジューラアクティベーションがアップコールする場所

+ このプロセッサを追加する(プロセッサ番号)
ユーザ層→走行可能なユーザ層スレッドを実行する

+ プロセッサが横取りされた(横取りされたアクティベーション番号とそのマシン
状態)
ユーザ層→横取りされたスケジューラアクティベーションで実行していたユーザ
	 層スレッドを走行待ち行列に戻す。

+ スケジューラアクティベーションがブロックした(ブロックしたアクティベー
ション番号)
ユーザ層→ブロックされたスケジューラアクティベーションはもはやそのプロ
	 セッサを使用していない。

+ スケジューラアクティベーションがブロックから復帰した(復帰したアクティ
ベーション番号とそのマシン状態)
ユーザ層→ブロックされたスケジューラアクティベーションで走行してたユー
	 ザ層スレッドを走行待ち行列に戻す。
----------------------------------------------------------------------

カーネルがスケジューリングの決定を他のものにする場所で正確に事象が伝達
されることを注記する。実際には、これらの事象は組み合わせで起き、それが
起きた時には一回のアップコールによって取り扱う必要のある全ての事象が伝
達される。

スケジューラアクティベーションの使い方の一つの例として、図1はI/O要求、
終了において何が起こるかを図解している。これはまれな状況であることを注
記する; 普通の操作では、カーネルの介入なしにスレッドは作成され、走行し、
終了する。図1のそれぞれの枠は異る時間ステップを表している。まっすくの矢
印はスケジューラアクティベーションを表し、S字の矢印はユーザ層のスレッド
を表し、それぞれの枠の右側にあるユーザ層スレッドの固まりは実行待ち行列
を表している。

時間T1では、アプリケーションにはカーネルによって二つのプロセッサが割当
てられた。それぞれのプロセッサでカーネルはユーザ層のコードをアップコー
ルし、そこで実行待ち行列からスレッドを外し走行開始させる。時間T2では一
つのユーザ層スレッド(スレッド1)がカーネル内でブロックした。この事象をユー
ザ層に通知するために、スレッド1で走行していたプロセッサをとり、新しいス
ケジューラアクティベーションとしてアップコールを実行する。そしてユーザ
層スレッドスケジューラはそのプロセッサを使って実行待ち行列の中のスレッ
ドを走行させることができる。

時間T3では、I/Oは終了した。再びカーネルはこの事象をユーザ層スレッドシス
テムに通知しなければならないが、この通知にはプロセッサを必要とする。カー
ネルはそのアドレス空間内で走行しているプロセッサの一つを横取りし、それ
を使ってアップコールする。(もしI/Oが完了した時、そのアドレス空間に一個
もプロセッサが割当てられていなかった場合、このアップコールはカーネルが
プロセッサが割当てるまで待たないとならない)

このアップコールによってユーザ層にはI/O終了と横取りの二つの事が通知され
る。アップコールによってユーザ層のコードは二つの事をすることが求められ
る(1) ブロックされたスレッドを実行待ち行列に置く。(2) 横取りされたスレッ
ドを実行待ち行列に置く。この段階でAとBのスケジューラアクティベーション
は放棄してよい。最終的に時間T4でアップコールは実行待ち行列からスレッド
をとってきて、それを実行開始する。

ユーザ層のスレッドがカーネルの中でブロックしたり横取りされた時、既にユー
ザ層の段階でそれを再開するのに必要な状態のほとんど、すなわちスレッドス
タックと管理領域である。しかしながら、スレッドのレジスタ状態はカーネル
の割込みハンドラや、ページフォルトハンドラのような低層で退避される。カー
ネルはこの状態を、I/O完了や横取りをアップコールによってアドレス空間に通
知する時に一緒に受渡す。

我々はまったく同じ機構を多重処理のためのアドレス空間の間でのプロセッサ
の再割当てに用いている。例えばカーネルがあるアドレス空間からプロセッサ
を取り上げ、他に与えるとする。プロセッサに割込みをかけ、アクティベーショ
ンを停止し、そのプロセッサを使って他のアドレス空間へ新しいアクティーベ
ションとともにアップコールすることによってなされる。カーネルは事前に前
のアドレス空間にその許可を得る必要はない。許可を得るようにすると、アド
レス空間の優先度を破るかもしれない(例えば、新しいアドレス空間は古いアド
レス空間よりも高い優先度でもあり得る)。それでも古いアドレス空間はその横
取りが起ったことを通知されないといけない。カーネルはこれを古いアドレス
空間でまだ走行している他のプロセッサを横取りすることによって実行する。
その二番目に横取りされたプロセッサは、古いアドレス空間に向って新しいス
ケジューラアクティベーションとともに、そのアドレス空間では「二つ」のユー
ザ層スレッドが停止されたことを通知することに使われる。そしてユーザ層の
スレッドスケジューラはこれらのスレッドをどう残りのプロセッサ上で実行す
べきかを制御する(アドレス空間の最後の一つのプロセッサが横取りされた場合
は、そのアドレス空間からの横取りをしない。その代わりに、このアドレス空
間にプロセッサに再割当てされた時までその通知を遅延する。通知によってユー
ザ層はどのプロセッサが割当てられたかを知ることができる。そしてこれは明
示的にキャッシュ局所性を管理するのに使える)。

 上記ではとても単純化していて、いくつかの考慮する点がある。一つは、もし
スレッドに優先度があった場合には、上記の例にさらに追加の横取りが必要に
なるかもしれない。例えば図1では、スレッド3はスレッド1,2より低い優先度だっ
たと想定しよう。この場合ユーザ層スレッドシステムはカーネルにスレッド3の
プロセッサを横取りしてもらうように求めることができる。そしてカーネルは
そのプロセッサを使って、ユーザスレッドシステムがスレッド3を実行待ち行列
に入れ、その代わりにスレッド2を走らせることができるようにアップコールを
するだろう。ユーザ層はどのスレッドがどのプロセッサで走行しているかを正
確に知っているので、追加の横取りを求めることを知ることができる。

二つ目に、カーネルがユーザ層スレッドを停止し、そのコンテキストを保存し
ているように記述しているが、カーネルとアプリケーションの相互作用は全て
スケジューラアクティベーションによってなされる。アプリケーションはスケ
ジューラアクティベーション上で、どのような並行性モデルでも構築できる。
つまりカーネルの挙動はどのような場合でもまったく同じである。特記するの
はカーネルはユーザ層での並行性を実現するデータ構造についてまったく知る
必要がないことだ。

三つめは、ユーザ層スレッドがまったく走行していない時にユーザ層スレッド
スケジューラの中で横取りやページフォルトが起きたとしても、スケジューラ
アクティベーションは適切に動作するということ。この場合、スレッドスケ
ジューラの状態はカーネルに退避される。その次に続くアップコールではもし
ユーザ層スレッドが走行中であれば、あるやり方で(再入可能な)スレッド管理
システムを再開し、走行中でなければ別のやり方で再開する。それは新しいア
クティベーションとそのスタック上で行なわれる。例えば、横取りされたプロ
セッサがアイドルループだったとしたら、何もする必要がない; もしアップコー
ル中に事象を処理している時であれば、ユーザ層のコンテキストスイッチは引
き続き事象を処理することができる。カーネルに追加される厄介な問題はプロ
グラムのページフォルトを通知するアップコールは同じ場所でまたページフォ
ルトするかもしれないことだ。カーネルはこれを調査しなくてはならなく、も
しこの状態が起きたら、ページフォルトが完了するまでアップコールを遅延す
る。

最後に、カーネル内でブロックされたユーザ層スレッドは、I/O完了の後、カー
ネルモードでさらに実行する部分があるかもしれない。そうであれば、カーネ
ルはもう一度ブロックするか、あるいはカーネルからユーザ層に戻るところま
でを一時的にスレッドを再開し実行する。後者が起った場合にはカーネルはユー
ザ層に通知し、ユーザ層スレッドのレジスタ状態をアップコールと一緒に受渡
す。

3.2 プロセッサ割当てに影響を与えるユーザ層の事象をカーネルに通知すること

3章の残りで述べる機構は、カーネルのアドレス空間の間でどうプロセッサを割
当てるかの方針とは独立である。しかしながら合理的な割当て方針はそれぞれ
のアドレス空間で利用される並行性モデルに基づかねばならない。ここでは

走行可能なスレッドが存在しない時にはプロセッサをアイドル状態にしないこ
とを保証し、優先度を大事にする方針のために、この情報が効果的に通信され
ることを示す。

これらの束縛は我々の知る限り、ほとんどのカーネルスレッドシステムに存在
し、カーネルスレッドの上にユーザ層スレッドシステムを構築した場合には存
在しない。重要な点は、ユーザ層スレッドシステムはスレッド操作についてな
にもカーネルに通知する必要がないだけでなく、いくつかの操作についてを(カー
ネルに伝えることで)カーネルのプロセッサ割当ての決定に影響を与えることが
できる点である。対照的に、カーネルスレッドを直接使った場合、次に走るス
レッド(オーバーヘッドを最小化し、キャッシュを持続させる一方、優先度に従っ
て選んだ)が同じアドレス空間のスレッドだったとしても、カーネルにトラップ
しないといけない。

我々のシステムでは、アドレス空間は、プロセッサより多くのスレッドが必要
になったり、走行可能なスレッドよりプロセッサが存在する時のように状態が
以降する時に、カーネルに通知する。アプリケーションが実行するのに余分な
スレッドを提供し、それに追加のプロセッサを割当てないのなら、システムの
全てのプロセッサは稼働中にならないとならない。さらに並行度を上げること
ではの束縛を破れない。同様に、アプリケーションがアイドル中のプロセッサ
があることをカーネルに通知して、カーネルがそれを取り上げない場合は、シ
ステムには他に仕事がない状態でないとならない。カーネルはアイドル中のプ
ロセッサが追加された通知を受ける必要がない。(このやり方の拡張で、アドレ
ス空間よりはむしろスレッドが全体的な優先度をもつ状況を処理することがで
きる)

表3には、これらのアドレス空間での状態の遷移によって呼び出されるカーネル
呼出しを一覧にした。例えばアドレス空間がカーネルにより多くのプロセッサ
が必要だと通知した時、アイドル中のプロセッサがあると登録されたアドレス
空間から探す。もしみつからかった時は、何も起こらない。しかし、この先ど
れか一つのプロセッサがアイドル状態になれば、最終的にこのアドレス空間は
プロセッサを獲得する。これらの通知はヒントでしかない: もしカーネルがア
ドレス空間にプロセッサを与え、その時にはもはや必要なかった場合、単純に
アドレス空間は更新された情報とともにプロセッサをカーネルに返す。もちろ
んその通知は順序の問題があるので、順序つけて通知しないといけない。

----------------------------------------------------------------------
表3 アドレス空間からカーネルへの通信

もっとプロセッサを追加せよ(追加として必要とされるプロセッサの数)

カーネル→より多くのプロセッサをこのアドレス空間に割当て、スケジューラア
	 クティベーションを実行して開始する。

このプロセッサはアイドル状態()
カーネル→このプロセッサを横取りして、他のアドレス空間に割当てる。

----------------------------------------------------------------------

このやり方の明らかな欠点は、アプリケーションのその並行度のOSへの通知が
正当でないかもかもしれないことだ。この問題はマルチプロセッサに特有の問
題ではない。正当でない、あるいは、間違ったプログラムは単一プロセッサ上
の並行処理でも不当に資源を獲得することができる。ユーザ層かカーネル層の
どちらかにおいて、多層のフィードバックによってアプリケーションにプロセッ
サの割当ての決定に対して正当な情報を提供するように促すことができる。プ
ロセッサの割当てにおいて、少ないプロセッサを使うアドレス空間の優先度を
高くし、多く使うアドレス空間は低くする。これによって他のどこかでプロセッ
サが必要な時にはアドレス空間にプロセッサを明け渡すことを促すことができ
る。優先度を示すことで、プロセッサが必要な時に返ってきそうだからだ。そ
の一方で、システム全体でプロセッサの数よりもスレッドの数が少ない場合に
は、アイドル状態のプロセッサは近い将来使われる時のためにそのアドレス空
間に留っているべきであり、これによってプロセッサ再割当てのオーバヘッド
を回避することができる。

多くの単一プロセッサOSでは、似たようなことをする。平均応答時間、とりわ
け対話処理の性能は、残りの時間が最少のジョブを優先することで改善され、
それはしばしば、実行時間の合計によってジョブの優先度を減らすことで近似
される。似たような方針をマルチプロセッサ上の並行処理に使うことで、同じ
結果が得られると期待する。この方針によって簡単にアイドル状態のプロセッ
サについて正しい情報を報告するようにしむけさせれる。

3.3 きわどい領域

これまでに検討していなかった問題の一つは、ユーザ層のスレッドは、ブロッ
クされたり横取りされたりする時に、きわどい領域を実行していることがあり
得る。(1
----------------------------------------------------------------------
(1 きわどい領域はwait-free同期[11]を使えば必要なくなるだろう。しかしな
がら、多くの商用プロセッサでは、wait-free同期を実装するのに必要なCPU命
令がない(我々は原子的なtest-and-setだけを想定している)。さらに、
wait-free同期のオーバーヘッドはとても小さなデータ構造を保護するには大き
過ぎることになるかもしれない。
----------------------------------------------------------------------

二つの悪影響がある。性能の悪化(他のスレッドはその横取りされたスレッドの
アプリケーションがロックしたままのスピンロックを取ろうとする)[28]、そし
てデッドロック(横取りされたスレッドが実行待ち行列のロックを保持している
こともあり得る。その場合、アップコールによってその割込まれたスレッドを
実行待ち行列に置こうとした時にデッドロックする)。きわどい領域がロックに
よって保護されていない場合でも起きる。例えばFastThreadはロックのないプ
ロセッサ毎(現実にはアクティベーション毎)の、自由に使えるスレッド管理領
域の一覧を、遅延時間を低減するために使っている[2]。これらの一覧を操作す
る時も原子的に行なわれないとならない。

都合の悪い横取りの問題を処理するのに、「予防」と「復旧」の二つのやり方
がある。予防では、カーネルとユーザ層の間でのスケジューリングやロックに
よって、都合の悪い横取りを防ぐ。とりわけ並行処理環境において「予防」に
はいくつかの重大な欠点がある。「予防」はプロセッサの割当ての管理を(少な
くとも一時的に)カーネルからユーザ層に渡す必要があり、アドレス空間の優先
度の意味論に違反する。「予防」はこの先4.3章で述べるきわどい領域に対する
実装と矛盾する。最終的に、「予防」では、ページフォルトがある場合、きわ
どい領域の間、そこで読み書きされるかもしれない全ての仮想ページを、物理
メモリに固定しておく必要がある。これらのページを同定するのは難しいこと
だ。

その代わりに、我々は「復旧」に基づいた解決方を採用した。アップコールが
ユーザ層スレッドシステムに、スレッドが横取りされたかブロックから解除さ
れたことを知らせる時、スレッドシステムは、そのスレッドがきわどい領域を
実行中かどうかを調べる(もちろん、この調査はいかなるロックを取得する前に
行なわれないといけない)。もしきわどい領域を実行中であれば、そのスレッド
はユーザ層によるコンテキストスイッチで一時的に実行を続ける。そしてこの
スレッドがきわどい領域を抜けたら、再びユーザ層のコンテキストスイッチに
よって元のアップコールに制御を戻す。この時点で、そのユーザ層スレッドを
実行待ち行列に戻して安全である。アクティベーションがカーネルの事象を処
理している最中に横取りされた時にも同じ機構を使って、処理を継続する。

この技法はデッドロックの制約がない。ロックを保持しているスレッドの実行
を続けることによって(それは最終的には開放される)、ページフォルトあるい
はプロセッサの横取りがあってもロックを確実に取得できる。さらには、この
技法はユーザ層のスピンロックにも使える。ユーザ層スレッドシステムは横取
りが起きた時には常に通知を受けるので、スピンロックを保持したスレッドを
継続して実行することが可能だからだ。正確さには影響がないが、プロセッサ
の時間は、スピンロックを保持したスレッドがページフォルトを起こすと無駄
にスピン待ちするかもしれない。これに対する解決は、しばらくの間スピンし
た後にはプロセッサを放棄することだ[4]。

4. 実装

3章で述べた設計に基づき、Topazとそのユーザ層スレッドシステムである
FastThreadsに変更を加えることで実装した。TopazはDEC SRC Fireflyマルチプ
ロセッサワークステーションのOSである。Topazのカーネルスレッド管理ルーチ
ンを改造してスケジューラアクティベーションを実装した。以前のTopazではス
レッドをブロック、再開、横取りしていた場所で、アップコールするようにし
て、ユーザ層がこれらに対して作用できるようにした(表2を見よ)。さらに、ア
ドレス空間に明示的にプロセッサを割当てるように改造した。以前はスレッド
のスケジュールはそれが属するアドレス空間に無関係であった。バイナリ互換
性も保持した。現存するTopaz(つまりUNIX)のアプリケーションも以前と同じよ
うに実行できる。

FastThreadsはアップコールを処理し、割込まれたきわどい領域から復帰できる
ようにし、そしてカーネルにプロセッサ割当ての決定に必要な情報を提供する
ように(表3を見よ)改造した。

全部で、FastThreadsには数百行、Topazには1200行ほど追加した。(比較として、
もともとのTOpazのカーネルスレッドの実装は4000行以上である) 新しくTopaz
に追加されたコードの多くは、プロセッサ割当ての方針(以下で述べる)に関す
るコードで、本質的にスケジューラアクティベーションではない。

我々の設計は、アドレス空間にプロセッサを割当てる方針と、プロセッサ上で
スレッドのスケジューリングの選択には中立である。もちろん、試作の実装に
はこれらの方針の組みあわせのいくつかを選ばないといけない。続く章では、
これらについての要約と、性能向上とデバッグに関する考察を述べる。

4.1 プロセッサ割当て方針

我々が選択したプロセッサ割当て方針は、ZahorjanとMcCann[27]の動的方針に
似ている。優先度を考慮し、仕事がある場合にはプロセッサが遊ぶことがない
ことを保証する間、プロセッサは「空間を共有する」方針である。プロセッサ
は最高優先度のアドレス空間の間で等しく分けられる。もしいくつかのアドレ
ス空間がそこで共有されているプロセッサが全ていらなくなれば、これらのプ
ロセッサは、それ以外に均等に分配される。空間共有によってプロセッサの再
割当てを減らすことができる。使用可能なプロセッサの数がそれを必要とする
アドレス空間の数の整数倍でない時だけ、プロセッサは時分割される。

全てのアドレス空間がスケジューラアクティベーションを使わないといけない
わけでなく、カーネルスレッドを使うこともできるように実装した。現存の
Topazアプリケーションを(この先も)実行できるようにするにはカーネルスレッ
ドもサポートしないといけないからだ。この実装では、カーネルスレッドを使
うアドレス空間は、スケジューラアクティベーションを使うアドレス空間と同
じやり方でプロセッサを獲得する。

カーネルのプロセッサ割当てはそれぞれのアドレス空間がより大くのプロセッ
サを使えるか、あるいは遊んでいるプロセッサがあるかの情報についてだけ知っ
ていればよい。(アプリケーションはどちらの状態でもないこともある。例えば、
プロセッサを要求し、それを受けとり、さらにプロセッサを要求することがな
い場合) 3.2章で述べたインターフェースによってスケジューラアクティベーショ
ンを使うアドレス空間からこの情報が提供される。カーネルスレッドを直接使っ
ているアドレス空間では、カーネル内部データによってこの情報は提供される。
スケジューラアクティベーションを使っているアドレス空間にはプロセッサは
アップコールを通してユーザ層のスレッドスケジューラに割当てられる。カー
ネルスレッドを使っているアドレス空間には元のTopazスレッドスケジューラに
プロセッサが割当てられる。結果として、プロセッサの静的な分割の必要がな
い。

4.2 スレッドスケジュールの方針

我々の設計の重要な面は、カーネルはアプリケーションの並行性モデルやスケ
ジュール方針、ユーザ層を並行性を管理するデータ構造について関知しないこ
とだ。アプリケーションのそれぞれは、これらについて適切なものを完全に自
由に選ぶことができ、そのアプリケーションに合わせて最適化することもでき
る。FastThreadsの規定の方針はプロセッサ毎の実行待ち行列を各自のプロセッ
サがLast-In-First-Outの順番である。これはキャッシュ局所性のためで、プロ
セッサは自分の実行待ち行列が空になったら仕事を探しにいく。これは本質的
にMultilisp[10]で使用されている方針である。

追加として、我々の実装では不必要なプロセッサの再割当てを防ぐために、履
歴効果を含んでいる。アイドル状態になったプロセッサはそれをカーネルに再
割当て可能と通知する前に、小時間スピンする。

4.3 性能向上

ここまでで述べた設計で、ユーザ層スレッドにカーネルスレッドと同等の機能
を提供するのには十分だが、その性能に対して重要ないくつかの考察がある。

これらのうち一番重要なのは3.3章で述べたきわどい領域に関する部分である。
ユーザ層スレッドが横取りされた時(あるいはカーネル内でブロックしたり、再
開可能になったとき)、きわどい領域を一時的に継続させるために、ユーザ層ス
レッドシステムはスレッドがロックを保持しているかどうかを調査できるよう
になっていないとならない。これの一つの方法として、きわどい領域に入った
らスレッドにフラグを立て、出る時にクリアする、そしてこれで継続している
かどうかを調べる。一時的に継続して実行されたスレッドが、それが安全な場
所まで来た時、プロセッサを放棄して元のアップコールに戻るのに、その調査
が必要である。あいにく、これはページフォルトや横取りが起きても起きなく
ても(これらはそう頻繁ではないにもかかわらず)、ロックの獲得と解除のオー
バーヘッドが大きい。これらの頻繁に起こるきわどい領域をユーザ層スレッド
システムの構築に使っているので、遅延時間はとりわけ重要である。

我々は一般的な場合にオーバーヘッドのない別の解決法を採用した。関連する
技術は、単一プロセッサ上のTrellis/Owlのガベージコレクタ[17]で使われてい
た。低層のすべてのきわどい領域の正確なコピーを作る。これは特別なアセン
ブラのラベルを使って、ユーザ層スレッドシステムのCのソースコード内のきわ
どい領域のそれぞれの区切りでこれを行なった。そして、コンパイラの生成し
たアセンブリコードを後処理して、コピーをした。これは言語とコンパイラの
支援があれば素直にやれるだろう。コピーの終了で、元の版とは違うきわどい
領域、プロセッサを放棄して再開するところに返るコードを置く。普通の実行
では元のコードを使う。横取りが起きると、カーネルは新しいスケジューラア
クティベーションをユーザ層への通知のために開始する。このアクティベーショ
ンは横取りされたスレッドのプログラムカウンタが、これらのきわどい領域の
どれかに該当しているかを調べ、もしそうであれば、対応するこれらのきわど
い領域のコピーの一つからスレッドを継続する。そのコピーによってきわどい
領域が終わったところで制御を放棄し、元のアップコールに戻る。普通の実行
では元のコードを使い、これは横取りに対処する処理を入れる前とまったく同
じコードなので、通常の場合ではまったくロックの遅延がない。(我々の実装で
は、時折きわどい領域の中で手続き呼出しをしなくてはならない。この場合、
直線経路ではなく、明示的なフラグをセット/クリアすることによって呼出しを
ひとまとめにする。)

二つ目の性能向上に重要なことは、スケジューラアクティベーションの管理に
関連することである。論理的にはそれぞれのアップコールに対して新しいスケ
ジューラアクティベーションが作成される。新しくスケジューラアクティベー
ションを作成するのには、そのデータ構造を割当て、初期化することが必要な
ため、制約がないわけではない。その代わりに廃棄されたスケジューラアクティ
ベーションを、いずれ再利用される時のためにとっておくことができる。ユー
ザ層スレッドシステムは、それまで実行していたスレッドがそのコンテキスト
から削除されたらすぐにそのアクティベーションをカーネルに返すことで、古
いスケジューラアクティベーションを再利用することができる。横取りの場合
では、ユーザ層に横取りを通知するアップコールを処理した後に。カーネル内
でブロックした場合では、ユーザ層に再開が可能であることを通知するアップ
コールの処理をした後に。似たような最適化は多くのカーネルスレッドの実装
で使われている。カーネルスレッドが一度作成されたら、破棄する時でもとっ
ておいて、この先のスレッドの作成を速くする[13]。

さらに、廃棄されたスケジューラアクティベーションを、一回ごとに返すので
はなく、集めておいてカーネルに一括して返すことができる。時折の廃棄の一
括返還を無視して、我々のシステムではI/Oやプロセッサ横取りでアプリケーショ
ン-カーネル境界をまたぐ回数を、伝統的なカーネルスレッドのシステムと同じ
にしている。カーネルスレッドのシステムでは、I/Oの初まりで一回、そして
I/Oの終了でもう一回、(カーネル/ユーザ)境界を越える。我々のシステムでも
同じカーネル境界の通過がある。

4.4 デバッグの考慮

Firefly Topazデバッガにスケジューラアクティベーションを統合した。二つの
分けられた環境があり、それぞれに要求がある: ユーザ層スレッドシステムの
デバッグと、スレッドシステムの上で動くアプリケーションのデバッグである。

透過性はデバッグには重要である。デバッガはデバッギの命令の並びにできる
限り影響がないようにするべきだ。前述のカーネルサポートではユーザ層スレッ
ドシステムにそれぞれの物理プロセッサの状態を通知するが、これはスレッド
システム自体がデバッグの対象となる場合には不適切である。代わりに、カー
ネルはそれぞれのスケジューラアクティベーションにデバッグする論理プロセッ
サを割当てる; デバッガがスケジューラアクティベーションで停止あるいはシ
ングルステップをした時には、これらの事象はユーザ層へのアップコールの対
象とならない。

ユーザ層スレッドシステムが正しく動いていると想定すると、デバッガはスレッ
ドシステムの機能を使って、ユーザ層スレッドのコンテキストで走行している
アプリケーションの状態を停止したり、調べることができる。

5 性能

我々の研究の目標は、カーネルスレッドの機能と、それぞれのアドレス空間上
のユーザ層で並行性を管理する性能と柔軟性を組み合わせることである。機能
と柔軟性については、これまでの章で検討した。性能の点で、三つの問題を検
討する。一つは、このシステムでユーザ層スレッド操作(即ち fork, block,
yield)のコストはどの程度か? 二つ目に、カーネルとユーザ層の間の通信コス
ト(具体的にはアップコール)はどうか? 三つ目は、アプリケーションの性能に
全体としてどの程度影響があるか?

5.1 スレッドの性能

ユーザ層スレッド操作のコストは、この研究の前からFireflyで使われていた
FastThreadsパッケージ(これはTopazのカーネルスレッドの上で走行する。シス
テムとの統合性は貧弱である)のそれと本質的には同じである。表4には、表1に
あった、元のFastThreads、Topazのカーネルスレッド、Ultrixプロセスのデー
タに今回のシステムのデータを追加した。

表4 スレッド操作の待ち時間 (usec)
----------------------------------------------------------------------------------------
		FastThreads on	FastThreads on		
Operation	Topaz threads	Scheduler Activations	Topaz threads	Ultrix processes
----------------------------------------------------------------------------------------
Null Fork	34    		37	  		948   		11300
Signal-Wait	37		42			441		1840
----------------------------------------------------------------------------------------

我々のシステムはユーザ層スレッドをカーネルスレッドの上で提供する利点を
そのまま保っている。Null Forkでは3usec元のFastThreadsより悪くなっている。
これは実行中のスレッドの数を増減することと、カーネルに通知するかを決定
することによる(単一プロセッサのマシン、あるいは利用可能なできるだけ多く
のプロセッサを常に要求する十分な並列性がある場合は、この部分はなくすこ
とができる)。 Signal-Waitでは5usecの悪化している。これは横取りされたス
レッドが再開しているのかどうか(その場合は、条件コードを復帰する余分な仕
事をしないとならない)を調べるコストによる。カーネルスレッドよりはまだ一
桁ほど性能がいいが、4.3章で述べたロックを保持した時のゼロオーバーヘッド
のやり方なしでは、とても性能が悪くなる。この最適化なしでは、Null Forkは
49usecに、Signal-Waitは48usecになる。(Null ForkはSignal-Waitにくらべて
より多くのきわどい領域がある)

5.2 アップコールの性能

スレッドの性能(5.1章)では、頻繁に起こる(カーネルとの関与のない)状況につ
いての特性を示した。アップコールの性能、これはまれに起こる状況であるが、
いくかの理由により重要である。一つは、損益分岐点を決定するのに役立つ。
カーネルスレッドより性能がよくなりはじめるのに必要な、ユーザ層で実行で
きるスレッド操作と、カーネルの関与が必要なスレッド操作の比である。もし、
ユーザ層スレッドをカーネルからスケジューラアクティベーションを使ってブ
ロックあるいは横取りするコストがカーネルスレッドのそれと同等であれば、
スケジューラアクティベーションは単一プロセッサ上では現実的には同じにな
りえる。さらに、スレッドが横取りされた時と、アップコールによってそれが
再スケジュールされた時の間の待ち時間によって、横取りされたスレッドが保
持しているきわどい資源のために、アプリケーションの他のスレッドがどの程
度待たないといけないかが決定される。

この実装を開始した時、アップコールの性能はTopazのカーネルスレッド操作と
同じくらいと期待していた。我々の実装はそれに較べて相当遅い。アップコー
ルの性能を測定の一つは、二つのユーザ層スレッドがカーネルを通してシグナ
ルし、それを待つ時間である。これは表4のSignal-Waitテストとその同期がカー
ネルによってなされるという点以外では類似している。これは、I/O要求やペー
ジフォルをスケジューラアクティベーションによって開始し、完結するオーバー
ヘッドの近似する。そのSignal-Wait時間は2.4msecでTopazスレッドより5倍性
能が悪い。この違いの原因となる、スケジューラアクティベーション固有の問
題はみつからない。それは二つの実装問題のせいである。一つはスケジューラ
アクティベーションをTopazのカーネルスレッドシステムのてっとりばやい改造
として作成したこと。もっと整備しなくてばならず、これをスクラッチからカー
ネルに設計した場合にくらべてオーバーヘッドがあるということ。重要なのは
Topazのスレッドシステムはアセンブラによって慎重に最適化されて書かれてい
る。我々のカーネル実装は完全にModula-2+によって書かれている。比較として、
SchroederとBurrows[19]はSRC RPCの処理コストをModula-2+からアセンブラに
書き直すことで4倍以上減らした。従って、最適化されれば、アップコールの性
能はTopazのカーネルスレッドの性能と同程度になると期待する。結果として、
次章のアプリケーションの性能の測定は、製品レベルのスケジューラアクティ
ベーションの実装よりは幾分悪い結果となる。

5.3 アプリケーションの性能

我々のシステムがアプリケーションに寄与する性能を例証するため、同じ並列
プログラムを、Topazのカーネルスレッド、Topazのカーネルスレッドの上に構
築された元のFastThreads、スケジューラアクティベーションの上で走るように
改造されたFastThreadsを使って測定した。測定したアプリケーションは、
O(NlogN)解のN体問題[3]である。アルゴリズムは、空間のそれぞれの部分の重
心の木表現にし、木を辿ってそれぞれについての力を計算する。離れた質量の
集合による力はその集合の重心からの力で近似される。

プロセッサ速度と使用可能なメモリ量の相対比によって、このアプリケーショ
ンは計算限界にもI/O限界にもなり得る。このアプリケーションのメモリ管理の
部分を、アプリケーションのデータのバッファキャッシュになるように改造し
た。こうすることで、アプリケーションで使うメモリの量を制御することがで
きる。問題を解くのに十分に小さいメモリサイズは、バッファキャッシュが
Fireflyの物理メモリに合うように選ばれる。一層の単純化として、スレッドが
そのキャッシュにミスしたら、カーネルの中で単純に50msecブロックすること
とした。キャッシュミスは普通ディスク操作をするだろう。(この測定は定性的
にディスク操作を考慮した場合と同じになる; Fireflyの浮動小数点性能と物理
メモリ量は現在のシステムに較べて一桁悪いので、あくまで例証だけというこ
とを意図している)

最初に、アプリケーションがカーネルサービスをほとんど使わない場合の説明
する。我々のシステムはTopazスレッドを使った場合に較べて、元の
FastThreadsと同程度にずっと速い。図2のでは、他のアプリケーションはなく、
ほとんどI/Oがなく、十分なメモリがある状態での、プロセッサ数の増加に対す
るアプリケーションの速度の向上をグラフにした。(速度の向上は、このアルゴ
リズムを単一処理した(並列処理をせずに)実装に対する比較である)

 1プロセッサでは3つのシステムとも単一処理実装より悪い。これは並行処理し
た時のスレッドの作成と同期のオーバーヘッドのためである。このオーバーヘッ
ドは他のユーザ層スレッドシステムよりも大きい。

プロセッサ数が増加するにつれて、Topazカーネルスレッドの性能は最初は良く
なるものの、その後は伸びない。Topazにおいて、スレッドはきわどい領域のア
プリケーションのロックの獲得/開放はカーネルを必要としないので、ロックに
対する競合はない。しかし、ビジーロックを獲得しようとする時には、スレッ
ドはカーネル内でブロックし、そのロックが開放される時だけ再スケジュール
される。このようにして、Topazのロックのオーバーヘッドは競合が起きるとと
ても大きくなる。よい性能を出した、ユーザ層スレッドはどちらも、アプリケー
ションとして十分な並行性を見せている。カーネルスレッドのオーバーヘッド
が性能向上の妨害となっている。

カーネルスレッドを使った場合、そのきわどい領域がボトルネックにならない
ように、あるいはロックが獲得できない時にカーネルに入る前にちょっとの間
ユーザ層でスピンする[12]ように再構成することでアプリケーションの性能を
向上するようにできたかもしれない。これらの最適化はユーザ層スレッドの上
でのアプリケーションでは重要ではない。

元のFastThreadsと我々のシステムとでは、4,5プロセッッサのあたりで性能が
異なる。このテスト中には他のアプリケーションは走行していないが、Topaz
OSはいくつかのデーモンが周期的に起床し、ちょっとだけ走行し、また寝る。
我々のシステムでは明示的にプロセッサをアドレス空間に割当てるので、これ
らのデーモンは、まったくアイドル中のプロセッサがない時にだけ横取りをす
る。これは元々のTopazのスケジューラでは違う。そのスケジューラは元の
FastThreadsの仮想プロセッサとして使われるカーネルスレッドを制御する。ア
プリケーションがその機械の全てのプロセッサを使おうとした場合(この場合、
6プロセッサ)、両方のユーザ層スレッドシステムの横取りの数は同じである。
(元のFastThreadsにとってその横取りの影響は少ない。その所用時間は小さい
からだ)

次に、アプリケーションがI/Oによってカーネルの介入を必要とする場合を見る。
我々のシステムは元のFirstThreads、Topazスレッドよりも良い性能である。図
3のグラフは使用可能メモリを変化させた場合にアプリケーションを6プロセッ
サで実行した時の所用時間である。3つのシステムで、最初のうちはゆっくりと
性能が下がっていく。そしてアプリケーションのワーキングセットがメモリに
入らなくなると急激に悪くなる。しかしながら、元のFastThreadsの性能は他の
二つに較べてさらに急激に悪くなる。これはユーザ層スレッドがカーネル内で
ブロックすると、その仮想プロセッサとしてのカーネルスレッドもブロックし、
そのためI/Oの間そのプロセッサをアプリケーションは使用できないからである。
我々のシステムとTopazスレッドの悪化率は同じである。これはI/Oの間に有効
にプロセッサを並行処理に利用できるからである。図2にあるように、それでも
我々のシステムでのアプリケーションの性能がTopazスレッドよりもいいのは、
ほとんどのスレッド操作がカーネルの介入なしに実行できるからである。

最後に、図3はアプリケーションによって引き起こされるカーネル事象による性
能への影響を示したが、並行処理が引き起こすシステムによるカーネル事象に
起因するものにも、我々のシステムは、他の二つ(元のFastThreadsとTopazスレッ
ド)よりも良い性能である。これを試験するために、二つのN体問題のプログラ
ムを6プロセッサのFirefly上で同時に実行し、その平均時間を測定した。表5に
はそれぞれのスレッドシステムでの速度向上を一覧にした。3倍の速度向上が限
界である。

----------------------------------------------------------------------
表5. N体問題 並列処理=2, 6プロセッサ 全てのメモリが使える状態

Topaz	Original	New
threads FastThreads	FastThreads
1.29	1.26		2.45
----------------------------------------------------------------------

我々のシステムは並行処理環境でも良い性能ことを表5は示している。3プロセッ
サで単一処理のプログラムを動かした時では5%以内の向上である。

この低下はバスの競合と、デーモンに周期的にプロセッサを明け渡す必要があ
るためだと思う。対照的に、異なる理由で並行処理環境での性能は元の
FastThreads、Topazスレッドともにもっと悪い。

元のFastThreadsをアプリケーションが使用した場合、OSは仮想プロセッサとし
て使われるカーネルスレッドを時分割する。これによってロックを保持したス
レッドがスケジューリングを外されている間、そのロックの開放を待っている
スレッドの物理プロセッサはアイドル状態となってしまう。Topazスレッドのス
レッドが我々のシステムより悪いのは、一般的なスレッド操作のコストが高い
からである。さらに、Topazは明示的なプロセッサの割当てをしないので、ある
アドレス空間は他のアドレス空間よりも、より大くのカーネルスレッドをスケ
ジュールされるかもしれない。図2では、3つ以上のプロセッサがアプリケーショ
ンに割当てられた時に、Topazスレッドは性能が伸びないことを示している。

Fireflyは概念を試作するにはとてもよい環境ではあるが、プロセッサの数が限
られているので、非常に並行度の高いアプリケーションや、並行実行環境での
並行プログラムの実行という実験には理想的ではない。このため、我々はスケ
ジューラアクティベーションをMachとそのCThreadsに実装している。さらに
Amber[6]というマルチプロセッサネットワーク用のプログラミングシステムを
このFireflyの上に実装している。


6 関連する考え

Psyche[20]とSymunix[9]という二つのシステムはカーネル支援を改良すること
でユーザ層のスレッドを適切に統合するという我々の目標ととても関連がある。
両方ともNUMAマルチプロセッサのサポートを最初の目標としていた。Simunixは
高性能な並列UNIX実装として、Psycheは新しいOSとして。

PsycheとSymunixは1,2章で述べたように「仮想プロセッサ」を提供し、ユーザ
層にいくつかのカーネル事象を通知するソフトウェア割込みを定義することで、
これらの仮想プロセッサを補強する。(ソフトウェア割込みは同一プロセッサ上
の全ての割込みは同じスタックを使うということ(なので再入可能ではない)以
外はアップコールのようなものである。) Psycheはさらに、いろいろな種類の
ユーザ定義のスレッドが、異るアドレス空間でそのコードとデータを共有しな
がら、同期できるような、複数モデルの並行プログラムを念頭に入れて調査を
している。

Psyche、Symunixと我々の研究は似た目標を共有しているが、それに対する手段
はいくつかの重要な点で異なる。我々のやり方と違い、PsycheもSymunixもI/O、
ページフォルト、並行プログラムに対するカーネルスレッドの正確な機能を提
供していない。さらにユーザ層スレッドの操作の性能は妥協したものになる。
この理由については2章でいくつか検討した。これらのシステムはアドレス空間
に影響を与えるカーネル事象の全てではなく、いくつかをユーザ層に通知する。
例えば、PsycheもSymunixも横取りされた仮想プロセッサが再開したことをユー
ザ層に通知しない。結果として、ユーザ層スレッドシステムは、いくつのプロ
セッサを持っているのか、どのユーザスレッドがこれらのプロセッサ上で走っ
ているのかを知ることができない。

PsycheとSymunixの両方ともカーネルとそれぞれのアプリケーションの間に書き
込み可能な共有メモリを提供しているが、両者ともカーネルがプロセッサ再割
当てが必要なことをユーザ層が通知する効果的な機構がない。それぞれのアプ
リケーションが必要なプロセッサの数はその共有メモリに書くことができるが、
より多くのプロセッサを必要とするアプリケーションが、他のアプリケーショ
ンでアイドル中のプロセッサがあることを知るいい方法がない。

PsycheとSymunixのアプリケーションは不適切な時に(例えばスピンロックを保
持している時など)横取りが起こるのを防ぐために同期状態をカーネルと共有す
る。Symunixではカーネルと共有する変数をアプリケーションがセットしクリア
することで、きわどい領域の中にいることを示す。Psycheではアプリケーショ
ンがきわどい領域に入る前に差し迫った横取りを調べる。これらのビットをセッ
トしたりクリアしたり調べることによってロックの遅延が大きくなり、これは
高性能なユーザ層スレッド管理をする時のオーバーヘッドの大きな原因となる
[2]。対照的に、我々のシステムでは、横取りが実際に起きていなければロック
遅延への影響がない。さらに、これら二つのシステムではプロセッサを横取り
したいということを、実際に横取りをする「前に」アプリケーションに通知す
る。この通知を元に、アプリケーションはスレッド「安全」な状態を選ぶこと
ができ、そして自発的にプロセッサを放棄する。この機構は高優先度のスレッ
ドは常に低優先度のスレッドの代わりに実行されるという束縛を破る。

Guptaらは[9a]物理プロセッサと走行するユーザ層スレッドの実行コンテキスト
の1:1対応を維持するという目的を、我々と同じくしている。プロセッサの数よ
りも多くのコンテキストがある状態で、I/Oが完了あるいは横取りをする場合、
Guptaらのカーネルはアプリケーションを安全に中断できるところまで時分割し
て実行させる。我々のカーネルでは、コンテキストの数を一定のまま、時分割
をせずに、アプリケーションにその事象を通知することができる。

いくつかのシステムでは非同期カーネルI/Oをマルチプロセッサ上でのユーザ層
スレッドのいくつかの問題を解決するのに使っている[9,25]。実際、我々のシ
ステムは非同期I/Oのような雰囲気がある。I/O要求ができると、プロセッサは
アプリケーションに戻り、そしてその後でI/Oが完了するとアプリケーションは
通知される。しかし、われわれのシステムと伝統的な非同期I/Oとの間には二つ
の大きな違いがある。一つは、一番重要なことだが、スケジューラアクティベー
ションはプロセッサの横取り、I/O、ページフォルトの問題に対して一つの一様
な機構を提供する。非同期I/Oに較べて、全てのカーネルとのやりとりは、一つ
のスケジューラアクティベーションという見地から同じになるということによっ
て、我々の手法は概念的な単純さを引きだしている。カーネル内でブロックし
たスケジューラアクティベーションは待っていた事象が起こると新しいスケ
ジューラアクティベーションに取り換えられる。二つ目に、非同期I/Oではアプ
リケーションとカーネルの両方に大きな変更が必要となるかもしれないが、我々
のやり方では、ユーザ層スレッドシステムとカーネルの構造を大きく変更せず
に済む。

最後に、我々のこの仕組みの一部は、最初期のマルチプロセッサOSの一つであ
るHydra[26]に関連があり、Hydraではスケジュール方針はカーネルの外に出て
いた。しかしながらHydraは、この分離によって性能が悪く、というのはその方
針の決定にカーネルとスケジュールサーバとの通信が必要だったからであり、
その後コンテキストスイッチの実装はカーネル内になった。我々のシステムで
はアプリケーションはスレッドをプロセッサにスケジュールする方針を自分で
設定することができ、そしてこれはカーネルにトラップすることなく実装でき
る。我々のシステムでは長時間のプロセッサ割当ての決定は、カーネルの責任
であるが、Hydraでは、これは別々のアプリケーション層のサーバに任せるよう
になっていた。

7 要約

並行性をユーザ層で管理することが高性能並列計算に重要である。しかし、多
くのOSで提供されてきたカーネルスレッドあるいはプロセスでは貧弱な抽象で
ある。我々は、カーネルスレッド(頻繁ではないが、カーネルの介入がある場合
に正しい振舞いをする)の役割りと、ユーザスレッド(ほとんどの場合のスレッ
ド操作は全てユーザ層だけで実装できる)の性能を組合せたカーネルインター
フェースとユーザ層スレッドパッケージの設計と実装、そしてその性能につい
て述べた。我々の手法は、アプリケーションそれぞれのアドレス空間に仮想プ
ロセッサを与えるということを基本にし、アプリケーションはいくつのプロセッ
サがあるかということを正確に把握し、これらのプロセッサ上でどのスレッド
が走行しているかということも正確に把握する。カーネルとそれぞれのアプリ
ケーションのアドレスの間でその責任が分離される。

- プロセッサ割当て(アドレス空間へのプロセッサの配分)はカーネルによって
  なされる。

- スレッドスケジュール(アドレス空間のスレッドをプロセッサへの配分)はそ
  れぞれのアドレス空間でなされる。

- カーネルはアドレス空間に影響を与える全ての事象をアドレス空間のスレッ
  ドスケジューラに通知する。

- アドレス空間は、カーネルのプロセッサ割当て方針に影響を与えるユーザ層
  の事象のいくつかをカーネルに通知する。

これらの考えを実装するのに使ったカーネル機構をスケジューラアクティベー
ションと呼んだ。スケジューラアクティベーションはカーネル事象にあたって
その制御をカーネルからアドレス空間に誘導する実行コンテキストである。ア
ドレス空間のスレッドスケジューラはこのコンテキストで事象を処理したり、
ユーザ層スレッドのデータ構造を変更したり、ユーザ層スレッドを実行したり、
カーネルに要求を送るのに使う。我々の試作ではスレッドをユーザ層での並行
性の抽象化モデルとして実装したが、スケジューラアクティベーションは特定
のモデルに特定されない。スケジューラアクティベーションでは、カーネルは
ユーザ層のデータ構造に一切よらないので、いかなるユーザ層の並行性モデル
でもサポートすることができる。

謝辞

Andrew Black, Mike Burrows, Jan Edler, Mike Jones, Butler Lampson, Tom
LeBlanc, Kai Li, Brian Marsh, Sape Mullender, Dave Redell, Michael
Scott, Garret Swart, John Zahorjanの有用な意見に感謝する。そして
Fireflyのソフトウェアとハードウェアを提供してくれたDEC System Research
Centerに感謝する。

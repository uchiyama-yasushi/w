Adding Scheduler Activations to Mach 3.0

Paul Barton-Davis, Dylan McNamee, Raj Vaswani, and Edward D.Lazowska
University of Washington

Technical Report 92-08-03 Reversed March 1993

Mach 3.0へのスケジューラアクティベーションの追加。

要約

ユーザ層のスレッドを伝統的なカーネルスレッドの上に構築すると、I/Oや、ペー
ジフォルト、プロッセッサの横取りによるカーネル操作によって低性能であっ
たり、正しくない動きをする。この問題は、ユーザ層のスレッドをスケージュ
ラアクティベーションという新しいカーネルにおける存在の上に構築すること
によって解決することができる。この論文で述べる効果の目的はMach3.0にスケ
ジューラアクティベーションを実装することだった。設計を決定し、必要なカー
ネルの変更、CThreadsライブラリに対して、新しいカーネルの構造を使う追加
を述べる。それとともに、スケジューラアクティベーションによる性能のコス
トを分離し、これらのコストよりこのアプローチの利点が上回ることを実証す
る。

1. 導入

ユーザ層スレッドを伝統的なカーネルスレッドの上に作ると、作成、終了、同
期のような一般の操作の性能に非常に効果がある。しかし残念ながらI/Oや、ペー
ジフォルト、プロッセッサの横取りによるカーネル操作によって低性能であっ
たり、正しくない動きをする。これはアプリケーションプログラマの板狭みと
して提起された。システムのサービスとしてよく統合されてはいるが普通の場
合の操作が重いカーネルスレッドを使うか、あるいは普通の場合の操作には良
い性能だが、システムに十分に対応していないユーザスレッドを使うかだ。

この板狭みを解決するために、Andersonら[ABLL92]はスケジューラアクティベー
ションという新しいカーネルの要素を設計した。スケジューラアクティベーショ
ンはユーザ層のスレッドの管理に適切なサポートを提供する。スケジューラア
クティベーションの上に構築されたユーザ層のスレッドはカーネルスレッドの
機能と、ユーザ層のスレッドの柔軟さと性能を組み合わせる。ここ数年で、ス
ケジューラアクティベーションは、ユーザ層の並行性を管理する正しいカーネ
ルの機構だという大方の意見になった。

この論文で述べる、試みの目標はスケジューラアクティベーションをMach3.0に
実装することだった。[RBF+89] この論文はその概念よりもその実装に重点を置
く。 設計上の判断、必要とされるカーネルの変更、CThreadsライブラリにこの
新しいカーネルの構造を使うために追加した事、について述べる。

1.1 ユーザ層スレッド

並行実行を表現する時、並行度の単位が小さければ、細粒度の並行実行はまあ
まあのオーバーヘッドでサポートすることができる。カーネルプロセス(Unixの
ような)は最も粗粒度の並行プログラム以外にはそのコストがあまりにも高いと
認められてきた。MachやTopazのようなマルチプロセッサOSはこの問題にカーネ
ルスレッドを提供することで取り組もうとした。しかしカーネルスレッドもま
たあまりにもコストがかかることがわかり、MachとTopazは現在、そのカーネル
スレッドの上に構築されたユーザスレッドを提供している。Andersonら
[ABLL92] はカーネルスレッドがユーザスレッドに較べたコストは、実装上の問
題ではなく、2つの原因による、それ本来の問題であることを論じた。

+ カーネルサービスのコスト。トラップされてカーネルに入るのは単純な手続
   き呼び出しに較べて、よりコストがかかる。アーキテクチャの潮流は、カー
   ネルトラップは相対的にコストがかかる方向になっている[ALBL91]。さらに、
   間違った振舞いのユーザプログラムから、カーネルを保護するために、シス
   テムを壊すような引数でないかどうか検査しないといけない。ユーザ層のス
   レッドパッケージは、スレッド管理の操作にカーネルトラップのオーバヘッ
   ドを避け、手続き呼出しを使うことができる。さらに、スレッドパッケージ
   は(カーネルスレッドのような)自分自身を守ることをする必要がない。間違っ
   た振舞いのプログラムが壊れるだけだからだ。

+ 一般化のコスト。 カーネルスレッドは全てに対して、全てを提供しないとい
   けない。あるプログラムがいくつかの特別な機能(例えば、ラウンドロビン
   割当て)が必要なくても、その機能が存在しているためのコストを払わない
   といけない。ユーザ層のスレッドパッケージは、それぞれのアプリケーショ
   ンの必要に応じて特別に最適化することができる[BLL88]。

ユーザ層のスレッドは比較的細粒度の並行性を表現するのに有効だということ
がわかった。残念ながら、ユーザ層のスレッドをカーネルスレッドのような、
今あるOSの機構の上に実装するのには難しい点がある。最初の問題は、カーネ
ルスレッドは、ユーザ層の状態にかかわらずスケジュールされること。カーネ
ルのスケジューラと、ユーザのスケジューラは、お互いに衝突してしまう可能
性がある。二番目の問題はI/O、ページフォルト、プロセッサ横取りのようなカー
ネルのイベントによって、ブロックする状態が、ユーザ層にはわからないこと
だ。様々な機構が、これらの問題のそれぞれについて取り組まれた。
[MSLM91][TG89] [Her91]、しかし、全ての困難さを扱った研究はなかった。ス
ケジューラアクティベーションは統合された解決法を提示する。

1.2 スケジューラアクティベーション

スケジューラアクティベーションはカーネルスレッドに代わって、ユーザ層の
並行性の管理をサポートをする。[ABLL92]に紹介されたように、スケジューラ
アクティベーションの環境は、以下の重要な特徴がある。

 + プロセッサはカーネルによってジョブに割合てられる。 プロセッサの割当
   てはカーネルによってユーザ層と通信した情報を元にしてなされる。カーネ
   ルはジョブにスケジューラアクティベーションを与えることで、プロセッサ
   を割当てる。その実体は伝統的なカーネルスレッドと同じようなものだが、
   以下に示す、追加的な特性がある。


 + ユーザ層のスレッドスケジューラはジョブに割当てられたプロセッサで走る
   スレッドの管理をする。カーネルによって与えられたスケジューラアクティ
   ベーションは、ユーザ層のスケジューラがスレッドを多重化する単純な容器
   である。スレッドのスケジューリングや、同期のような一般的な操作はカー
   ネルの介入なしに、ユーザ層において効果的に実行される。

 + ユーザ層が、カーネルにプロセッサ要求の変化を通知する。 ジョブの並行
   性が、その現在のプロセッサ割当てから上下する時にカーネルは通知される。

 + カーネルは、ユーザ層のスケジューラに、そのジョブに影響を及ぼすシステ
   ムイベントを通知する。これらのイベントはカーネルの中で起こる、プロセッ
   サの割当て、横取りや、ブロック、起床を含む。カーネルの役割りは、「イ
   ベントを処理する」から、適切なジョブのユーザ層のスレッド管理システム
   に「イベントを通信する」ことに変わる。これによって、ジョブに対して適
   切な方法でイベントを処理することができるようになる。

 + カーネルはスケジューラアクティベーションを時分割しない。スケジューラ
   アクティベーションはカーネルがジョブにプロセッサを割当てる手段である。
   ジョブは常に正確に、できるだけ多くのスケジューラアクティベーションを
   物理的なプロセッサがあるだけ持つ。カーネルは(与えられた数の)スケジュー
   ラアクティベーションを(より少ない数の)物理的なプロセッサの上に多重化
   しない。

 + アプリケーションはこの新環境を使うとしても、変更の必要はない。これは
   イベントの管理はユーザ層のスレッド管理システムにカプセル化されている
   からで、そのインターフェースに変更はない。

このシステムに馴染みのない読者は、この先に進む前に[ABLL92]を読むことを
強くお勧めする。

1.3 Machにおけるスケジューラアクティベーション

Andersonの試作実装はDEC SRCのFireflyマルチプロセッサワークステーション
上のOS、Topazの変更によってなされた[TSS88]。これは優秀な試作環境ではあ
るが、その実装は他者には触れることのできないものであるし、その実験は最
大で6プロセッサに限られていた。

我々の目標は、様々なプラットフォームに広く一般に使われているカーネルに、
スケジューラアクティベーションを統合することである。それにMach 3.0を選
び、この研究を20プロセッサのSequent Symmetryで動かすことになった[LT88]。

我々の実装は幾つかの役割りを果たすだろうと思う。一つは、適度な数のプロ
セッサにおいて、スケジューラアクティベーションという概念が、妥当かどう
かの最終的な結論を出すだろう。二つ目には、これが、プロセッサの割当ての
アルゴリズム、スレッド割当てのアルゴリズム、効果的な通信プリミティブと
共にユーザ層のスレッドを統合すること、I/O、仮想記憶の管理をユーザ層です
る準備、そしてその先、に対する研究の基本となること。三つ目にはMachの他
のプラットフォームにスケジューラアクティベーションを実装する際の手本と
なるだろう。

この実装に着手するにあたって、Machの都合のいい互換性と機種非依存性を選
択した。その目標に関して、システムへの変更は最少にしたく、できる限り現
存のカーネルの機構を使うことにした。結果としてのシステムが広く使えるよ
うに、Machの後方互換性にも努めた。例えば、既にあるカーネルスレッドのイ
ンターフェースもサポートしている。最終的に、できる限り機種非依存に実装
して、他のプラットフォームにも簡単に実装できるようにした。スケジューラ
アクティベーションを基本として全体を再構成するのではなく、実験のたたき
台となるように試みた。最高の結果を求めるのはこの実装の目的ではない。む
しろ、一般にあるマシンで、どこを最適化するのが効果的なのかを実験するの
を期待する。この取りかかりによって、この実装がより理解でき、変更可能に
なることを期待している。

1.4 枠組の設計

スケジューラアクティベーションのモデルにおいて、それぞれのジョブのユー
ザ層スレッドシステムは、それに割当てられたプロセッサの制御をし、この割
当てが変更されたら、通知される。カーネルは、ジョブに割当てられたプロセッ
サ毎にスケジューラアクティベーション(実行コンテキスト)を提供し、関連す
るイベントがあれば、通知する責任を負う。

Machのカーネルスレッドの振舞いを変更することでスケジューラアクティベー
ションを実装した。我々の実装の構造に影響する、一つの重要な設計上の決定
はプロセッサ割当てモジュールの導入で、これは、ある意味Machの既存のカー
ネルスレッドのスケジューラを置き換えるものである。Machカーネルのスケー
ジューリング方針はスレッド基底で、"quantum-driven"である。この方針は伝
統的な仕事量に対しては適切だが、スケジューラアクティベーションのアプリ
ケーションと、カーネルの間で伝達される情報を活用するという方針において
は、荷が重い。ただし、Machの「プロセッサセット[Bla90]」によって、標準の
スレッド基底の方針(これは我々の目的には不適)を回避でき、それを我々のタ
スク基底のものに置き換えることができる。プロセッサセットは、タスク、ス
レッド、プロセッサの割当てのカーネルの機能である。
我々の設計は、それぞれのタスクはそれ自身のプロセッサの組を持つ。

方針モジュールは、タスクに応じた割当ての判定と、タスク間の優先度に基い
て様々なプロセッサの要求を監視する。この新しい方針モジュールはカーネル
内でもユーザ層のサーバでも実装できる。色々な方針を試すことのできる柔軟
性のある後者を選んだ。これから先に述べる、我々が最終的に選択した方針は、
ユーザ層の「プロセッサ割当てサーバ」にカプセル化し、選択すれば既存のカー
ネル機構を使うことができるものである。: プロセッサはそのタスクのプロセッ
サセットによってよって割当てられ、そしてそれは、そのセットから除かれる
ことで横取りされる。この設計は、このシステムが三つの要素から構成される
ことを意味する。

+ イベントの通知のような基本的な機構を実装するためのカーネルの変更。こ
  れらは次の章で検討する。

+ スケジューラアクティベーションで使われるタスクの間で割当てられるプロ
  セッサの管理をするユーザ層のサーバ。このサーバの実装と、その方針につ
  いては三章で検討する。

+ この新しいカーネルの機構を使うためのユーザ層のスレッドパッケージ。こ
  れは四章で述べる。

2. スケジューラアクティベーションのためのカーネル支援

この章ではスケジューラアクティベーションをサポートするためにMach 3.0 カー
ネル*(MK78)に加えた変更について説明する。* UXサーバへの変更は必要ないカー
ネルからの観点では、スケジューラアクティベーションは伝統的なMachのカー
ネルスレッドであり、タスクに起因する(あるいは影響する)、イベントをユー
ザ層に反映するという追加的な特性をもつ。

2.1 初期化

変更されたMachカーネルは、伝統的なMachのタスク(これらはMachのカーネルス
レッドを要求する)と、スケジューラアクティベーションを使うタスクの両方を
サポートする。タスクは次に示す新しいシステムコールを使って、スケジュー
ラアクティベーションを使用することをカーネルに通知する:

 + task_register_upcalls (task, upcalls). ユーザ空間の入口の組を登録す
   る: ユーザ層へのアップコールルーチンのアドレスである。

 + task_recycle_stacks (task, count, stacks). カーネルに'count'個のユー
   ザ空間のメモリを提供する。カーネルがアップコールをする時、これらの領
   域の一つがスケジューラアクティベーションのアップコールのユーザ層の実
   行スタックとして使われる。特定のスタック上の情報が、タスクにとって有
   用でない時、カーネルは検知できないので、タスクがこれらのスタックを管
   理する必要がある。タスクはアップコール中のカーネルの使用のために、ス
   タックは常に使用可能であることを保証しないといけない(4.4.2章を見よ)

 + task_use_scheduler_activations (task, TRUE). カーネルのタスクの構造
   体のスケジューラアクティベーションを使うビットを設定。タスクがこ
   の'using_sa'ビットを設定したなら、そのタスクで作られる全てのカーネル
   スレッドは、(これに関連する)ビットを設定する。この'is_sa'ビットはカー
   ネルスレッドは事実上、スケジューラアクティベーションだということを意
   味する。カーネルはこのビットを以下に述べる特定のイベントを、どう処理
   するかの決定に使う。

   この呼び出しの副作用として、呼び出したカーネルスレッド(タスクの中の
   たった一つだけ実在するスレッドを想定する)は、スケジューラアクティベー
   ションに変化する。この呼出しから戻ってきた時には、タスクはスケジュー
   ラアクティベーションの意味論での、その通常な実行を続けるだろう。

タスクの状態を管理するのに、柔軟性のために複数のシステムコールを使うこ
とにした。この方法は初期化時間に多少のオーバーヘッドがあるが、最終的に
タスクの状態をよりよく管理できる(例えば、いつでも、登録されたアップコー
ルハンドラを変更できるというような)ということに対して許せる代価であると
みなした。

2.2 カーネルイベントの扱い

スケジューラアクティベーションの枠組の中で、特定のカーネルイベントはタ
スクに通知される。通知はカーネルからユーザ層へのアップコールとして実装
され、その引数は以下に述べる通りである。カーネルからユーザ層に送られる
のは四つの通知がある。

 + blocked (new_sa, event_sa, interrupted_sas): new_saはevent_saがブロッ
   クされたことを伝える。interrupted_sasは通知を配送するために割込まれ
   たかもしれないアクティベーションを照会する(*)。2.2.1章で述べるように、
   この'blocked'の通知の場合ではこの引数は常にNULLである。(*)この場所は
   interrupt_sas(複数形)と呼ばれる。それはアクティベーションは通知の準
   備をしている間にカーネルの中でブロックされることがあるからだ。この場
   合では、幾つかのアクティベーションは最終的に配送される前に割込まれて
   いるかもしれない。

 + unblocked (new_sa, event_sa, interrupted_sas): new_saはevent_saのブ
   ロックが解除されたことを通知する。interrupt_sasは通知を提供するのに
   横取りされたかもしれないアクティベーションを照会する。

 + preempted (new_sa, event_sa, interrupted_sas): news_saはevent_saがプ
   ロセッサの再割当てよって横取りされたことを通知する。interrupted_sas
   は通知を提供するのに割込まれたかもしれないアクティベーションを照会す
   る。

 + processor_added (new_sa, event_sa, interrupted_sas): new_saは新しく
   プロセッサがタスクに割当てられたことを通知する。この通知では
   event_saとinterrupted_sasは両方ともNULLである。(2.2.4章を見よ)

これらの四つの通知の実装は以下に続く四章で述べる。まず最初に必要となる
背景について規定する。2.2章の以下の部分は相当詳細だということを確認して
おく。

スケジューラアクティベーションの状態の決定的な構成要素はそのユーザ層で
の継続で、それは、カーネルの継続([DBRD91]で述べられた)に似ているが、ユー
ザ層に戻るのではなく、カーネルルーチンを指定して戻る。これを、アクティ
ベーションの実行をアップコールからユーザ層に制御を移したい時に設定する
(2.2.1章を見よ)。

スケジューラアクティベーションはevent_saとinterrupted_sasの二つの引数も
あり、それは他のアクティベーションの場所であり、通知の間にそれらの情報
をユーザ層に伝えることを許している。この情報はアクティベーションそれ自
身、それが実行したいたプロセッサや、そのユーザ層のレジスタ状態を含んで
いる。

カーネルはthread_select ()で、次に事項するスケジューラアクティベーショ
ン、あるいはカーネルスレッドを選択する。

プロセッサ毎のフラグを、thread_select ()が通知が必要かどうかのために管
理する。このフラグの値は、PROC_SA_BLOCKEDがブロックしたイベントに、
PROC_SA_HANDLING_EVENTが通知中に、PROC_ALLOCATEDが、プロセッサセット間
でのプロセッサの再割当てである。thread_select()が、プロセッサのイベント
フラグがこれらの値であれば、通知をする手配をする。

次の章では、一般的な用語でイベントの扱いについて述べる。さらに詳細な
記述は付録 A.3にある。


2.2.1 ブロック

アクティベーションがブロックされた時、その'event_sa'はアクティベーショ
ンそれ自身の時点として設定され、そのユーザ層への継続はsa_notify(カーネ
ルルーチン)に設定される(これらはブロックが解除される時に使われる;2.2.2
章を見よ)。プロセッサのイベントフラグはPROC_SA_BLOCKEDに設定される。こ
れによって、thread_select()は新しいスケジューラアクティベーションを通知
するために作成する(他の実行可能なアクティベーションを選ぶのではなく)。
新しく作られたアクティベーションのevent_saはブロックされたアクティベー
ションを指し示す。新しいアクティベーションはsa_notify()で初まり、それは
アップコール用の引数を置くためにユーザ層のスタックをとってくる。その引
数は現在のアクティベーションと、ブロックされたアクティベーションである。

ユーザ層のスタックは、トラップから返るようにその場で設定され、プログラ
ムカウンタはタスクのアップコールの入口であるsa_blocked()に設定される。
最終的に、通知のためのアクティベーションはthread_exception_return()を使っ
て、ユーザ層で実行を始める。


2.2.2 ブロック解除

ブロックの解けたイベントは、(ディスク読み込みのような)ブロックするイ
ベントの後にアクティベーションを実行可能にするカーネルの手続きによって
開始される。

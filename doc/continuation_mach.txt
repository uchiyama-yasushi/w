Using Continuations to Implement Thread Management and Communication
in Operating Systems.

Richard P. Draves Brian N.Bershad Richard F.Rashid Randall W.Dean Oct
1991

OSのスレッド制御と通信の実装に継続を使う


要約

 我々は、内部のスレッドとプロセス間通信の枠組を継続をその制御の移行の基
本として使うように再設計することによって、Mach3.0 OSの性能を向上させた。
以前の版のMach 3.0に較べて、新しいシステムはスレッドあたり85%の少ない空
間を消費する。アドレス空間をまたがる、遠隔手続き呼び出しでは14%早くなる。
例外処理は60%速くなる。システム性能の向上に加えて、継続をOSに共通な制御
移行の最適化として一般化し、これらの最適化を一つの実装方法論の視点から
作り直した。この論文ではMach OSで継続を使用するにあたっての我々の経験に
ついて記述する。

1. 導入

 継続を実行コンテキスト間の制御移行の基底として使うように、Mach 3.0 OS
を再設計することで大幅な性能の向上を達成した。我々のシステムでカーネル
内でスレッドがブロックされるのは二つの方法がある。一つは、レジスタ状態
とスタックを保存し、その状態を元に戻すことで実行を再開する。もう一つは、
継続としての再開(スレッドが走る時に実行されるべき関数)を指定する。継続
としてスレッドをブロックすることを許すことによって、カーネルプログラマ
は、スレッドの管理の時間と空間を押さえることができる。継続を使うことに
よって、スレッドはそのスタックをブロックされている間、捨てることができ
る。その結果カーネルの中のスレッドの空間を押さえることができる。

 継続によってまたスレッドはブロックされている間の実行状態の高レベルの表
現をすることができ、その状態を調べて、作用することができるので、制御移
行のオーバーヘッドを軽減することができる。

 継続を使うことが難しい場合には、継続によってスレッドをブロックしないこ
とによって、カーネルプログラマは伝統的な様式の並行処理プログラミングが
できる。

 継続によってMachカーネルの記憶領域の必要量を減らすことができ、実行時の
性能も向上した。以前に較べて、例えばDECstation 3100上の最適化版のMach
3.0はスレッド毎に資源を持つのではなくプロセッサ毎にカーネルスタックを持
つスレッドは85%の空間で済む。

 アドレス空間をまたぐ遠隔手続き呼びだし(RPC)は14%速い。例外処理の性能は
UNIXではないOSのエミュレーションに決定的で、2倍から3倍で性能が向上した。
さらに、継続によって一つの実装方法論の見地から多くの制御移行の最適化が
可能になった。

 この論文で述べるシステムはカーネギーメロンや他の場所の研究者が日常的に
使用している。マルチスレッドプログラミングと分散コンピューティングをサ
ポートするのにスレッドとプロセス間通信に頼ったMachのようなOSのカーネル
に対して、この制御移行を管理するのに継続を使う技術は似たような結果をも
たらすと信じている。

1.1 OSカーネル内での制御の流れの管理。

過去において、OSはカーネル内の実行形態は二つのうちのどちらかによってき
た。プロセス形態と割り込み形態だ。プロセス形態では

カーネルのアドレス空間はシステム内の全てのスレッドのために一つのスタッ
クを持っている。スレッドが、システムコールやフォルトによってカーネルに
トラップされると実行状態を保持するために専用のカーネルスタックを使う。
このやり方では、スレッドはブロックされている間その全ての状態を保持して
あるので、カーネル内の実行中はいつでも、そのスケージュリングをすること
ができる。UNIX[Ritchie & Thompson 78]はこのプロセス形態によるOSの例だ。

プロセス形態とは対照的に、割り込み形態はシステムコールとフォルトを割り
込みのように扱う。:全てのカーネル内実行は、カーネルアドレス空間内のプロ
セッサ毎の一つのスタックを使う。カーネル内でブロックしたスレッドは、は
じめにその実行コンテキストに対する情報を退避しなければならない。この退
避された情報は後にブロックされたスレッドが適切な状態で再開するために使
われる。QuickSilver[Haskin et al. 88]とV[Cheriton 88]はこの割り込み形態
によるOSの例だ。

プロセス形態の一番の利点はプログラムが簡単なことだ。カーネルスレッドは
ブロックしたり、ページング可能な記憶領域を参照するのに「特別な」制限が
ない。残念ながらプロセス形態には性能に関する問題が二つある。一つ目はそ
れぞれのスレッドがカーネルアドレス空間のスタックを必要とするため、プロ
セス形態は大量の記憶領域を消費してしまう。二つ目は、カーネルスタックが
ブロックされたスレッドの状態が、リターンアドレスや退避されたレジスタ、
自動変数を機械レベルで反映しているので、その状態を評価するのと、スレッ
ドの移行管理の遅延を減らすための最適化をすることが難しい。

1.2 Machにおける制御移行の歴史の概要

初期の版のMachカーネルは二つの理由によりプロセス形態によっていた。一つ
はMachカーネルはAccent[Rachid & Robertson 81]の後に作られ、それはプロセ
ス形態を使っていた。Machの全体的な設計と実装は直接Accentに由来していた
のでAccentのプロセス形態を使うのが自然だった。二つ目は初期の版のMachは
UNIX互換層をカーネルモードで実行していた。この層はプロセス形態である
BSD Unix[Leffler et al.89]を使って実装されていた。これらのコードがカー
ネル内に残っているため異なる形態を使うことは大変な努力が必要だ。

Machの発展につれて、プロセス形態は適切でないことが明らかになってきた。
Accentではスレッド管理の基本操作はマイクロコードによって行なわれ、そし
てそれらは機械のCPU速度にくらべて十分に速かった。対照的にMachは広い範囲
のアーキテクチャで動くように設計された。なのでマイクロコードがスレッド
管理の手間を軽減するという仮定はできなかった。さらにAccentと違って、
Machは一つのアドレス空間に対して多数のスレッドの管理をサポートする。こ
れは結果として少量のプログラムが大量のカーネルスレッドを使うことになっ
た。プロセス形態ではこれらのスレッドはそれぞれ4KBのスタックをカーネルア
ドレス空間にもつ。最終的にUnix互換コードはカーネルからユーザ空間に移動
[Golub et al.90]したので、純粋にUnix互換をサポートするためのプロセス形
態を使う必要はもはやなくなった

プロセス形態の再検討は小さいシステムや、速いRISC単一プロセッサ、マルチ
プロセッサへの効果的な実装の要求によって加速した。今日一般に見つかるワー
クステーションは32MB、それ以上のメモリを積んでいるけれど、我々はMachを
小さいPC、ラップトップやノートブックで効率的に走らせたいと欲した。それ
らは大抵8MB以下程度のメモリである。結果としてカーネルのメモリ消費量の低
減が重要になった。さらに、プロセッサの速度の増大とともに、キャッシュと
TLBのミスの相対的なコストも増した。もしカーネルスタックをスレッド毎では
なくプロセッサ毎とできれば、カーネルスタックを参照する時のキャッシュ、
TLBミスの数が減るだろうと期待した。さらに、Machはキャッシュ一貫性マルチ
プロセッサの上でも走る。そのような機械ではプロセッサ毎のデータ構造とし
て扱うと最も効率的だ。[Anderson et al. 89]

あるスレッドから他のスレッドに制御が移行する遅延時間についても関与した。
我々の高速プロセス間通信(IPC)システム[Draves 90, Bershad 90]のデザイン
の経験では低い遅延時間の制御移行についていくつかの重要な教えがあった。
我々はこの知恵を一般的な方法として、カーネル層での制御移行に適用したかっ
た。とりわけOSは多くの部分はユーザ層で実装されているので、アドレス空間
間のRPCに低遅延は重要とはいえ、それ以外例外処理のような経路も重要になっ
てきた。高速例外処理は、例えば、仮想メモリの基本操作をユーザ層から使う
[Appel & Li 91]場合や、OSの上で他のOSをエミュレートする時に必要になって
くる。さらに、Machは広範囲のプロセッサ上で動くので一般的な解決方を機種
非依存に適用できることが重要だ。その場限りのアセンブリ言語による性能の
向上策は許容できない。

1.3 いくつかの適切でない解決策

非常に初期、カーネル内の大量のスレッドを管理に関連する大きさと速度のの
問題を処置をする必要があることに気付いた。最初の解決策として、ユーザ層
のスレッド、C-Threads[Cooper & Daves 88]を、ユーザ層のスレッドをカーネ
ル層のスレッドの上に多重化するように変更した[Golub et al 90]。一つのカー
ネル層スレッドが同じアドレス空間を同じくする多数のユーザ層スレッドをサ
ポートすることで、大量のスレッドのために必要とされるカーネル空間を低減
しようという狙いだ。さらに他[Anderson et al. 91, Marsh et al.91]で注意
したように、ユーザ層のスレッドは、同じアドレス空間内でのスレッドスイッ
チの遅延を低減できる。

我々のC-Threadsの使用は緩和したが、プロセス形態の空間的問題は解決されな
かった。第一に、カーネルスレッドはアドレス空間の間で共有できないので、
アドレス空間毎に少くとも一つのカーネル層のスレッドがまだ必要だ。Machを
このようにしたことで、重大な保護の問題が発生した。それぞれのエミュレー
トされたUnixプログラムは一つのカーネルスレッドをUnix「プロセス」として
使う。そして、C-Threadのマルチスレッドプログラムは少なくとも一つのカー
ネルスレッドをそれを「仮想プロセッサ」として使う。

ユーザ層スレッドをカーネルのプロセスの上に置く形態の二番目の問題はカー
ネルの中で実行中にブロックされたスレッドはカーネルスタックを消費したま
まだということだ。結果として平均して、C-Thredadはシステム中のカーネル層
スレッドの数の低減は1/2程度にしかならないことに気付いた。

ユーザ層スレッドはアプリケーションとカーネルの関わりが少ない場合、性能
の向上に優れているマルチプロセッサプログラムはカーネルから離れている傾
向にあるが、サーバのようなマルチスレッドプログラムの我々の経験では、そ
れらは例えばIPC、ページフォルト、例外によってカーネルに集中する。なので、
ユーザ層スレッドは部分的にマルチスレッドプログラムの空間要求に手段を講
じるが、それだけでは十分ではない。カーネルの問題を、カーネル側の解決方
が必要だった。

QuickSilverやRIG[Ball et al. 76]のようなシステムの経験により、割込み形
態を考慮することになったが、最終的にはMachカーネルには不適切と結論づけ
た。割り込み形態は、スレッドがそれ専用のカーネルスタックを持たないため、
カーネルの使う資源が少ないのが魅力だ。他方で、この形態はプログラムが難
しい。というのは、ブロックする可能性のある操作は全て、状態を退避/復帰す
るための特別の目的のコードを必要とするからだ。

さらにこのコードはモジュールの境界を越えて覗かないといけないかもしれな
い、ブロックするモジュールはその状態をその呼び出し元のために保存するこ
とができるため。これはシステムの維持管理性の障害となる。Machはマルチプ
ロセッサ上で動く(すなわち内部でロックが使われる)、そして仮想メモリをサ
ポートする(つまりカーネルはページフォルトできる)ので割込み形態では管理
不能と感じ、だから許容できない。

1.4 継続による再構成

スレッドがブロックする際にプロセス形態でも割込み形態でも使えるように
Machカーネルを再構成した。プロセス形態を使ってスレッドがブロックする時
はその現在の実行状態はスタックに記録される。ブロックされたスレッドはコ
ンテキストスイッチによって再開される。スレッドが割込み形態を使ってブロッ
クする時は、実行状態をそれが再開されるべき場所の補助的なデータ構造に記
録する。それは継続[Milne & Strachey 76]と呼ばれる。ブロックしたスレッド
はとっておいた継続を呼び出すことで再開される。この新しいやり方は、プロ
セス形態、割込み形態をそれひとつで使うより、いくつかの利点がある。

+ プロセス形態の「使い易い」という利点がある。スレッドはそのスタックの
  内容をそのままでカーネル内のどんな時でもブロックしてもいい。これは割
  込み形態が便利ではない状況の時に重要だ。セマフォでブロックする時スレッ
  ドが深くネストした関数の中である時や、カーネルで実行中にページフォル
  トをする場合だ。

+ 割込み形態の性能のよさがある。 カーネルのコンテキストがない、あるいは
  ほとんどないスレッドの時、言ってみればそれが他のスレッドからのメッセー
  ジを受信するために待っている時、あるいは、次の命令がユーザ空間で実行
  すべき時、そのカーネルスタックは全部放棄していい。さらに、継続は機種
  非依存なインターフェースで使われるので継続を実行時に調べて、そしてそ
  れを使うのを回避するすることがしばしば可能だ。システムの現在の状態は
  その使用が必要ないようにできる。XXX

+ 他のOSに見つかる、多くの実行時の最適化の実装を一般的なフレームワーク
  とインターフェースとして提供できる。多くの制御の移行に対する低層の最
  適化は継続によって作り直すことができる。例えばハンドオフスケジューリ
  ング[Black 90b, Thacker et al 88]、スタックなしカーネルスレッド
  [Thacker et al.88],非同期I/O[Levy & Eckhouse 89]、カーネルからユーザ
  のアップコール[Hutchinson et al.89, Anderson et al.91, Scott et
  al.89]、軽量遠隔手続き呼出し[Bershad et al. 90]それぞれはIPCの最適化
  と、継続を使って記述し実装できるスレッド管理システムを表現している。
  さらに、継続の機種非依存なインターフェースを定義することによって、こ
  れらの最適化は可搬性のあるコードで達成できる。

Machカーネルの中の様々な制御の移行を継続によって扱い、多くの場所に小さ
い最適化を一様なやり方で適用することでシステムの性能の向上を可能にした。

この論文ではMach 3.0 OSでの継続の使用とその性能について述べる。二章では
Machでの継続の実装について述べる。三章では継続を使用し、それによる最適
化の性能向上について調べる。四章では他のOSで見られるいくつかの制御移行
の関数にどうやって継続を実装することができるかを明らかにする。五章では
関連する研究について議論する。最後六章では我々の結論を要約し、紹介する。

2. OSカーネルで継続を使用する

この章ではカーネルプログラマの視点で継続を述べる。プロセス形態のカーネ
ルを継続が使えるように変換し、継続によっていくつかの一般的な最適化技術
が可能になる。そしていくつかの重要なカーネルサービスの継続による効果を
明らかにする。最後にMachカーネルでの継続を管理する機種非依存なインター
フェースを紹介する。

2.1 継続を作る

継続を必要とする二種類の制御の移行がある。スレッドがトラップあるいはフォ
ルトしてユーザ空間からカーネル空間に入る時のユーザとカーネルの境界の移
行と、カーネルの中であるスレッドから他のスレッドに制御が移る時だ。

ユーザ層でのシステムコール、例外、割込みは制御をカーネルに移行する。カー
ネルの入口では、カーネルから呼ばれた時に、制御をユーザ層に戻す継続を作
成する。制御は呼び出し元に戻らない。システムコールはそれを呼び出した所
へシステムコールの返り値とともに戻る継続を生成する。ユーザプログラムへ
の返り値はない例外と割込みは、後に呼び出されるところに継続を生成する。

カーネルの中ではスレッドはプロセッサを放棄する時に継続を作成する。スレッ
ドをブロックするカーネル手続きに関数ポインタを渡すことでこれはなされる。
関数はスレッドの継続になり、それはカーネルの機種非依存なスレッドデータ
構造として保存される。一層の実行時最適化がなければ、スレッドはその継続
の呼び出しによって再開される。


/* よく使われるシステムコール (変換前)*/
example(arg1, arg2) {
	P1(arg1, arg2);
	if (ブロックする必要) {
		/* プロセス形態を使う */
		thread_block();
		P2(arg1);
	} else {
		P3();
	}
	/* 制御をユーザに戻す */
	return SUCCESS;
}

/* よく使われるシステムコール (変換後)*/
example(arg1, arg2) {
	P1(arg1, arg2);
	if (ブロックする必要) {
		/* 継続を使う */
		コンテキストをスレッドに退避する;
		thread_block(example_continue);
		/* NOTREACHED */
	} else {
		P3();
	}
	/* 制御をユーザに戻す */
	thread_syscall_return(SUCCESS);
}

example_continue() {
	コンテキストをスレッドから復帰する;
	P2(復帰したarg1);

	/* 制御をユーザに戻す */
	thread_syscall_return(SUCCESS);
}

図1: ブロックするカーネル手続きの変形

継続として特定された関数は通常の関数のように返らない。それは他の関数を
呼ぶか、継続のみしてよい。この点がクロージャと継続の違いだ。割込み形態
として、もしブロックするスレッドがどんな状態もブロック中に保持していな
ければならないのなら、明示的に全て保持しないといけない。カーネルのスレッ
ドデータ構造体は、28バイトのスクラッチ領域を含んでいる。もし、スレッド
がもっと大きな状態を保持しておきたいのなら、追加のデータ構造を割当てな
いといけない。そのような、簡便に、あるいは有効に継続とともにブロックを
することが不可能な場合、NULLを引数としてブロックする関数を呼べば、プロ
セス形態としてスレッドをブロックする。スレッドのコンテキストはスタック
に保持され、スレッドは同じコンテキストで再開する。

2.2 カーネルを継続を使うように変換する。

Machカーネルを継続を使うように変換するのは卒直な処理だった。まず最初に
カーネルの関数のうち、ブロックする可能性があり、そして少量の状態だけが
ブロックされている間に保持されればいい関数を見きわめた。そして、これら
の関数を二つの部分に分けた。:ブロック前と、その後に。ブロックの後、ある
いは継続からなる新しい関数を定義し、ブロック前の部分だけを元の関数に残
した。次に二つの部分のに共通なスタックの内容を見きわめて、それらをブロッ
クするスレッドのスクラッチ領域に蓄えるようにした。ブロック前の関数にお
いて、カーネルのブロックする関数に、ブロック後の関数を引数とするように
変更した。その関数はスレッドの継続となる。最後に、ブロック後の関数を呼
び出し元に戻るのではなく、継続を呼ぶように変更した。図1は変換例を図解し
ている。一つの関数は二つになり、二番目の関数はブロックする一番目の関数
の引数になる。

ほとんどの場合、ブロックするカーネルの関数を継続に書き替えるのは難しく
なかった。ユーザスレッドがトラップされてカーネルに入る場合、一番最初に
ブロックが起きるのはメッセージの受信、例外、ページフォルト、プリエンプ
ションだ。それぞれは、ユーザからカーネルの移行(システムコール、例外、割
込み)の結果として起き、そしてそれぞれは処理されて、制御がカーネルに移っ
た時に作成された継続を使って、ユーザ層へ戻る。

 カーネルの中だけで走るスレッドに対しては「ユーザ層に戻る」継続はない。
実際問題として、ほとんどのカーネルスレッドは無限ループで、イベントが起
こるまでブロックし、なにか作業をして、またブロックに入る。このようなス
レッドに対して、ループの本体を含む関数への継続を定義する。関数の最後の
文はこの関数自体への継続を共なったブロックになるので、その結果、末尾再
帰呼び出しによって無限ループを作ることになる。


2.3 継続を使った最適化技法

継続によってカーネルの性能を高める三つの一般的な制御の移行の最適化をす
ることができる。スタック放棄、スタック渡し、継続認識の三つだ。

継続はスレッドが再開するコンテキストを指定する。なのでスレッドのカーネ
ルスタックはブロックしている間、放棄することができる。これは空間と時間
を節約する。カーネルはブロックされているスレッドのスタックを他のスレッ
ドのスタックとして使うことができるので、空間を節約できる。さらに、もし
次に走るスレッドが継続を共なってブロックされていて、そのスタックを放棄
していたら、スレッドはブロックしているスレッドが放棄したスタックを直接
使うことができる。この二番目の最適化は「スタック渡し」と呼ばれる。カー
ネルのメモリ要求の軽減によって、継続は時間も節約することができる。それ
はカーネルの作業領域が減るので、TLBとキャッシュを有効に使えるようになる
からだ。

継続に制御を移す間の時間は最初に継続を実行時に(保持された継続、それは関
数ポインタであり、知られた値と比較することができる)調べることで減らすこ
とができる。この技術は継続認識と呼ばれ、スレッドが再開される時に、より
特定の(そして速い)コードを、スレッドの継続の替わりに使うことができる。
XXX さらに、スタック渡しの後にスタックポインタの変更なしに、再開された
スレッドは特定のコードをブロックしているスレッドの関数呼び出しコンテキ
ストで実行することができる。XXX

2.4 アドレス空間をまたいだRPCで継続を使う

MachにおけるOSサービスはアドレス空間をまたぐRPCを用いてユーザ層のサーバ
によって使われる。継続を使ってカーネルのRPC経路を再構成して、性能を向上
させた。

図2はMach RPCの半分を呼び出しの高速な経路を示している。単一のシステムコー
ルmach_msgはRPCの送信と受信の段階を一つの操作に統合する。依頼スレッドは
mach_msg をRPC要求メッセージをサーバにに送り、返信メッセージを受信する
ために使う。サーバスレッドはmach_msgを返信メッセージを依頼スレッドに送
り、そして次の要求メッセージを受信するのに使う。両方の場合で送信スレッ
ドは受信スレッドを起こし、そしてメッセージが届くまで自分自身をブロック
する。

送信スレッドはカーネルに入り、そしていずれユーザ層に戻る時の継続を作成
する。そして、受信することのできるスレッドを探す。もしそのようなスレッ
ドがみつからなかったら、遅い経路を使い、メッセージは待ち行列に入る。も
し送信者がスレッドを見つけたら、スタック渡しを受信者に対して行なう。こ
れは、送信スレッドをmach_msg_continueで、継続を共なったブロックされた状
態にしておき、そして、カーネルスタックを持たない。受け渡しは現在走行中
のスレッドから受信スレッドに変更するが、すぐには受信スレッドの継続を呼
ばない。その代わりに受信スレッドは送信者のmach_msgシステムコールのコン
テキストで走る。ここでスレッドは自分自身の継続をそれを使う前に確認する。

もしそれがmach_msg_continueであれば、受信者は同じ経路でブロックしたので、
mach_msgは高速RPC経路で完成し、カーネルの外に受信者のコンテキストで移行
する。それ以外に、mach_msgは受信者の保持された継続をカーネル内のメッセー
ジの処理のために呼びだす。XXXこれは起こり得る。例えば、受信者が最大量の
ような珍しいオプションや制限を特定した時。これは余分な処理が全ての受信
に対して必要で、なので受信者はさらに仕事をするために別の継続でブロック
しているかもしれない。実際のところ、余分な仕事はまれに必要になるだけで、
ほとんどのスレッドはmach_msg_continueと共にブロックする。

 継続を使用することによってRPC中の空間と時間のオーバーヘッドが軽減する。
Machの中のほとんど全てのスレッドは、通常メッセージを待っていているので、
それらがブロックしている間、そのカーネルスタックを放棄している。呼出し
の遅延は受渡しによって、ブロックしているスレッドはそのまだ活動中の関数
が再開するスレッドのコンテキストを呼ぶことができるので軽減される。XXX
再開するスレッドは以前に退避した継続を使って制御の以降を完成させてもい
いし、あるいは継承されたコンテキストの情報を使って、別の高速な経路を使っ
てもいい。この状況で、送信者と受信者のメッセージ処理はお互いに最適化す
ることができる。例えば、高速RPC経路は待ち行列の操作、何度もの同期、何度
も例外状況を調べるためにメッセージを解析することを避ける。その替わりに
メッセージは暗黙的に共通のスタックの上にあり、送信者は共有データ構造を
ロックし、受信者はそのロックを外す。そして送信者だけが、受信者でなく、
メッセージの例外的な状況(大きいデータのような)を確認する。

2.5 他の種類の制御の移行に継続を使う

RPC経路が一番繁雑に使われるけれど、いくつかの他のカーネル経路についても
継続を使用した。これらの経路は三つで、例外処理、スレッドプリエンプショ
ン、ユーザ層ページフォルトで、それぞれ異なるやり方で継続を適用すること
ができることを示そう。

 + 例外処理
 Machにおいて、全てのスレッドは例外サーバを持っていて、それはカーネルが
RPCとともにスレッドが例外を起こした時には呼ぶ。例えば、スレッドが読み込
み専用ページに書き込もうとして例外が起きた(それは共有の仮想メモリ上で動
いているため[Appel & li 91])、あるいは、特権命令を実行した(Machは
MS-DOS、Macintosh OSのような別のOSをエミュレートするため[Rose & Hacker
85])。例外サーバはカーネルカラの要求メッセージを受信して、それを処理し
ようと試み、ちょうど受けとった例外の状況の返答メッセージをカーネルに送
り返す。ほとんどの場合、サーバは例外を処理することができ、その返答メッ
セージによってカーネルが即座にフォルトを起こしたユーザ空間のスレッドを
再開する。
ユーザからユーザのRPCと違うにもかかわらず、例外サーバとやりとりでは、カー
ネルは通信の終点になる。継続を使って例外処理の遅延を軽減した。例外メッ
セージを送信するのに通常の経路に入る前に、フォルトを起こしたスレッドは
ここではカーネルモードで実行されているが、サーバスレッドがメッセージを
待っている状態かどうかを調べる(継続、mach_msg_continueを使って)。もしフォ
ルトしたスレッドがサーバを見つけたら、要求メッセージを作るのを延期して、
即座にサーバスレッドに対してスタック受け渡しをして、フォルトの情報を共
有されたスタックで直接渡す。これはフォルトしたスレッドがメッセージを送
信し、サーバがこれを受けとるようにした時のコピー、解析、待ち行列を操作
することを回避する。もし、mach_msg_continueで待っているサーバがない時は
遅い経路が使われる。

 + プリエンプティブスケジュール
スレッドの横取りは時計割込み中、もし現在のスレッドの実行単位が終了した
ら行なわれる。もし割込まれたスレッドがユーザ層であれば、割込まれてから
積まれたスタックは重要でなくなる。なぜならスレッドは単純にユーザ層の場
所から再開されるからだ。なので割り込まれたスレッドはユーザ層へのスレッ
ドに戻る継続を共なってブロックする。
 横取りへ継続を使うことが意味することは、最も走ることができて、しかし実
際には走っていないスレッドはカーネルスタックを必要としないということだ。
それはまた再スケジュールの遅延を少し軽減する。というのは、横取りされた
スレッドは再スケジュールされた後にカーネルスタックを巻き戻す必要がない
からだ。

 + ユーザ層ページフォルト
スレッドがユーザ空間の用意されていないページでフォルトした鴇、カーネル
が空いている物理ベージを見つけてそこにデータを積むまでブロックしないと
いけない。カーネルのフォルト処理はスレッドを、新しいページをマップして、
そしてユーザ層のスレッドを再開する継続と共にブロックする。フォルトした
スレッドのスタックの消費を軽減し、ほとんどメモリが残っていない時のカー
ネルのメモリの消費を簡便に軽減する。
 この最適化はユーザ層ページフォルトにのみ適用できる。カーネルでフォルト
した場合、そのカーネルの状態とスタックは保存される。カーネル層のページ
フォルトは継続を適用することがとても難しい例で、それは一般的にスレッド
はカーネル内の実行中のどこでもフォルトするからだ。この難しさのため、こ
の場合については、プロセス形態に頼ることにした。

継続はスレッドがユーザ層から自発的にそのプロセッサを放棄する時や、カー
ネルの内部スレッドが作業を待つためにブロックする時にも使われる。最初の
場合では、保存するカーネルの状態はない(横取りの時と同じように)。二番目
の場合では、2.2章で述べた末尾再帰を実装するのに継続を使用できる。

2.6 可搬性のあるOSカーネルでの継続の実装

stack_attach(thread, stack, cont)
  	switch_contextがスレッドを再開し、制御を用意された継続の関数に
	前に走っていたスレッドを引数として渡し、制御を移行するように、
	機種非依存な継続を機種依存の変形し、割当てられたカーネルスタッ
	クに積み、スタックを初期化する。
	
stack_detach(thread)
	スレッドのカーネルスタックを取り外して返す。

stack_handoff(new-thread)
	スタック受渡しをする。つまり現在のスレッドのカーネルスレッドを
	新しいスレッドに移動する。stack_handoffは必要であればアドレス空
	間を変更する。stack_handoffは新しいスレッドとして返る。

call_continuation(cont)
	現在のカーネルスタックポインタを初期化して、提供された継続を呼
	ぶ。この関数は、長く継続の呼び出し続く時にスタックが溢れるのを
	防ぐ。

switch_context(cont, new-thread)
	新しいスレッドをその保存されたカーネルスタックで再開する。もし
	必要ならアドレス空間を変更する。もし、現在のスレッドの継続が提
	供されたらswitch_contextはレジスタを保存せず、返らない。そうで
	なければ、switch_contextは現在のスレッドのレジスタとスタックを
	保存し、呼び出し元のスレッドが再スケジュールされたら、以前走っ
	ていたスレッドに返る。

thread_syscall_return(return-value)
	ユーザ空間からのシステムコールに返り値を特定して現在のスレッド
	のユーザシステムコールの継続を呼ぶ。(低層の機種依存トラップが
	システムコールの継続を作成する)

thread_exception_return()
	ユーザ空間から例外あるいはページフォルトしたスレッドに戻るために
	現在のスレッドの例外継続を呼ぶ。(低層の機種依存トラップが例外の
	継続を作成する)	

図3:機種依存の制御移行関数のカーネルインターフェース


thread_handoff(cont, new_thread) {
	old_thread = current_thread();
	old_thread->cont = cont;

	/* stack_handoff は current_thread()を変更する */
	stack_handoff(new_thread)
	/* ここで current_thread() == new_thread */

	/* スケージュリング状態を更新 */
	old_thread->state = WAITING;
	new_thread->state = RUNNABLE;
}

thread_continue(old_thread) {
	new_thread = current_thread();
	thread_dispatch(old_thread);
	(*new_thread->cont)();
	/*NOTREACHED*/
}

thread_dispatch(old_thread) {
	if (old_thread->cont) {
		stack = stack_detach(old_thread);
		/* スタックをプールに返す */
		stack_free(stack);
	}
	if (old_thread->state == RUNNABLE)	
		/* old_threadをrun queueに返す */
		thread_setrun(old_thread);
}

thraed_block(cont) {
	/* 現在のスレッドを止める */
	old_thread = current_thread();
	
	/* ready queueから次に走るスレッドを選択 */
	new_thread = thread_select();
	
	if (new_thread->cont) {
		if (cont) {
		   /* stack_handoffはcurrent_thread()を変更する */
		   stack_handoff(new_thread);
		   /* ここでcurrent_thread() == new_thread */
		   
		   old_thread->cont = cont;
		   if (old_thread->state == RUNNABLE)
			/* old_threadをready queue に返す */
			thread_setrun(old_thread);
		   call_continuation(new_thread->cont);
		   /*NOTREACHED*/
		} else {
		   /* 新しいスタックを作成 */
		   stack = stack_allocate();
		   stack_attach(new_thread, stack, thread_continue);
		}
	}
	
	thread_dispatch(switch_context(cont, newthread));
}

図4:制御移行インターフェースの使用


Mach 3.0カーネルはあらゆるプロセッサで動く。この可搬性はカーネルを機種
非依存部分、これはMachのカーネルインターフェースであり、機種依存の部分
は機械を管理する。機種非依存の部分は、スケージュリング、プロセス間通信、
仮想記憶を管理する。機種依存の部分は下層の機械的なトラップ、例外やMMUを
実装し、新しくスタックと継続の内部インターフェースを提供する。

新しいインターフェースは機種非依存のスレッド管理とIPC部分が、アドレス空
間を変更したり、スタックとスレッドの関係を管理したり、継続を生成、呼び
出すことを可能にする。その操作は図3に表にした。インターフェースはブロッ
クしたスレッドの継続に対して確認をしない。それはカーネルの機種非依存な
スレッドのデータ構造として保存されているので、カーネルモードで走るスレッ
ドは直接調べることができる。

図3のルーチンは高レベルのスレッド管理の操作をする操作の基本部分である。
図4に、いくつかのこれらの操作と、インターフェースがカーネルの中でどのよ
うに使われるかを紹介する。thread_handoffは特定されたスレッドに対して制
御を与える。それは、スタック受渡しをして、スレッドのスケジューリングの
情報を、古いスレッドはブロックされ、新しいスレッドが走っているように更
新する。関数は新しいスレッドの制御として返るけれど、新しいスレッドの継
続は呼ばない。これによって、thread_handoffの呼び出し元は継続認識(RPCや
例外処理の経路のような)をする機会がある。対称的にthread_blockは実行可能
なスレッドを選ぶ。もし、新しいスレッドが継続を持っていて、thread_block
の呼び出し元が継続を提供していたら、より効果的なstack_handoffの経路を使
う。そうでなかったら、witch_contextを呼ばなくてはならなくて、これはスタッ
クを変更する。

thread_blockの実装はswitch_context,stack_attach,stack_detachの相互作用
を説明している。thread_blockは古いスレッドのスタックの上で実行している
間は、古いスレッドのスタックを外すことも開放することもできないし、他の
プロセッサが見つかるかもしれない走行待ち行列にこの古いスレッドを置くこ
ともできない。したがって、その実装の最初のswitch_cotextは新しいスレッド
のスタックに変更し、新しいスレッドはthread_dispatchを使って古いスレッド
を処分する。もし新しいスレッドがスタックを持ってなかったら、
stack_attachはそれを初期化して、thread_continueを実行する。それは新しい
スレッドが古いスレッドを処分した後に呼ばれる継続を呼ぶ。

2.7 マイクロカーネル(原文Kernelized)の優位さ

Machにおける継続の有効さはMachがマイクロカーネルのOSだとい事実に起因す
ると思う。それは少ないインターフェースを提供し、いくつかの抽象概念だけ
を実装している。結果として、Machカーネルの中でスレッドがブロックするの
は小数の場所であり、実際にスレッドがそこでブロックするのいはさらに少な
い。Mach 3.0カーネルでスレッドがブロックし得る場所は大体60の場所がるけ
れど、99%以上のブロックは6つの場所だけである。期待されたように、この再
構成をこれらの「熱い場所」に焦点をあてた。カーネルの中の経路でまだ継続
が使用されていない場所はあるけれど、それらはまれな経路であり、それらの
性能への影響は無視できる範囲だ。
 対照的に、Mach 2.5のようなモノリシックOSに、継続を使うことはより難しい
ことだと思う。あのシステムではBSD Unixインターフェースを全部カーネルの
アドレス空間で実装していた。大くのスレッドはUnix互換層の深い位置でブロッ
クする。このようなスレッドに対して継続を作成するのは、大量の状態がその
カーネルスタックに乗った状態であるため、難しい。さらに、Mach 2.5では
180以上の場所でスレッドはブロックする可能性があり、「熱い場所」もない。
これらの理由から、少ない場所で継続を使うことができて、それが全体的な空
間と時間の軽減となったと思う。

2.8 ソフトウェア工学との関係

実際の継続の懸念はそれを使い過ぎることにある。割込み形態のカーネルが導
入で記述した問題に苦しんで終わってしまったことを避けるために、継続は思
慮深く適用されなければならない。この継続の使い方の鍵は、プロセス形態の
上でほとんどのカーネルの作業が同じように作業(ブロック)するというところ
だ。結果として大部分のシステムは、割込みモデルにするより、安定している。
継続を使った経路のコードは、呼び出し元が確実であることを信用しないとい
けないのでそういう意味では壊れやすい(例えば、thread_syscall_returnを使
うコードは、これ用に実装されたシステムコールでないといけない)。しかし、
システムの性能の向上の高く抽象化された方法を適用して、妥当な譲歩だと思
う。XXX

2.9 要約

継続はOSの抽象化の'first-class object'を進めることによって得られる一貫
性とその作用によって表現される。'first-class object'とはカーネルによっ
て操作されるものである。この意味で、継続はMachのpmapの抽象化[Rashid et
al. 87]に似ている。pmapは仮想から物理のメモリのアドレスマップを反映す
る'first-class object'である。メモリマップを抽象化し、それを機種依存の
実装(ページテーブルやセグメントレジスタ)と分離することで、pmapインター
フェースは可搬性があり、本来できなかった方法で最適化[Young et al. 87]す
ることができた。カーネルの'first-class'の抽象化としての継続は似たような
結果をあげた。


3 性能

この章では性能における継続の効果を調べる。空間に関しては、カーネルの中
の制御の移行のほぼ全てを継続を使うようにして、スタックなしでスレッドを
ブロックできるようになったことを示した。これは効果的にカーネルのスタッ
クをプロセッサ毎の資源とできる。時間に関しては、大くの制御移行を継続認
識を使うようにした。これはアドレス空間をまたぐ通信と、ユーザ層の例外処
理の遅延を軽減する。

3.1 実験環境

三つの版のMachカーネルを評価した: MK32, MK40とMach2.5。 MK32とMK40は
Mach 3.0の純粋カーネルで、Unixシステムコールインターフェースをカーネル
アドレス空間で実装していない。MK32は継続を使っていないが、アドレス空間
をまたぐRPCのオーバーヘッドを軽減する最適化[Draves 90]を含んでいる。
MK40は二章で述べた継続を使っている。Mach 2.5はBSD Unixインターフェース
をカーネル空間で実装した、合いの子カーネルで、MK32におけるRPCの最適化も、
継続も使っていない。

全てのカーネルはDECstation 3100(DS3100)とToshiba 5200/100で動く。
DS3100はMIPS R2000を基本としたワークステーションで、64KBの命令データ分
離キャッシュと4段の書き込みバッファをを持つ。それは16.67MHzで、キャッシュ
落ちや、書き込みストールがなければ、1サイクルごとに1命令を実行する。我々
のDS3100は16MBのメモリと250MBのHitachiのディスクドライブで構成されてい
た。Toshiba 5200はIntel 80386 20MHzを基本にしたラップトップで、32KBの命
令、データ統合キャッシュである。我々のToshiba 5200は8MBのメモリと100MB
のConnerディスクドライブから構成されていた。

Mach 3.0カーネルはUnixサーバへのRPCとして実装されたUnixシステムの環境で
試験した。さらにToshiba 5200ではMS-DOSエミュレーションも測定した。
MS-DOSエミュレータMS-DOSのシステムコールと特権命令から起きるフォルトを
ユーザ層の例外処理が掴まえる。その例外処理スレッドはエミュレートした
MS-DOSプログラムのアドレス空間で動く。

3.2 継続の使用の動的な頻度

継続の価値はどれだけの頻度でそれが使われるかによる。これを測定するため
に、Toshiba 5200でMK40カーネルでブロックする処理が継続を使う回数を計測
する3つのテストをした。一つ目のテストは短かいCのコンパイルベンチマーク。
二つ目はAFS(分散Andrewファイルシステム[Satyanarayanan et al.85]上で
Mach 3.0カーネルを作成。三つ目のテストはMS-DOSのビデオゲームである「ウィ
ングコマンダー」で測定した。小さいコンパイルと、MS-DOSはシングルユーザ
モードでテストした。カーネルの作成はマルチユーザモードでテストした。
AFSはネットワークサービスとユーザ層のファイルキャッシュマネージャが必要
だからだ。表1に結果をまとめた。DS3100 でも頻度は似ている。MS-DOSのゲー
ムはToshibaでしか動かないので例外。
 表によって99%の制御移行が継続を使い、スタック放棄を使っている。一番頻
度が高いのはメッセージの受信と例外処理である。他の処理は、ページフォル
ト、自発的な再スケージューリング[Balck 90a]、自発的でない横取り、そして、
カーネル内部のスレッドによるブロックである。残る、継続を使わずにブロッ
クする処理はカーネルのページフォルト、メモリ割当て、ロックの獲得で起こ
る。これらの状況で継続を作成することは難しいため、MK40ではプロセス形態
を使ってカーネルスタックをブロックの間保持したままとしている。
 表2はスタック渡しがほぼ全ての制御移行で起っていることを示している。さ
らにアドレス空間をまたぐRPCと例外処理で起こる、継続認識は、ブロック処理
の60%以上で起こる。

3.3 継続に起因する速度の向上

継続がアドレス空間をまたぐRPCと例外処理の実行時の性能を向上されることを
示す。RPCテストはアドレス空間をまたぐ"null"RPCの往復の時間を測定した。
例外処理のテストはスレッドの例外をユーザ層のサーバが処理する時間を測定
した。例外サーバはフォルトするスレッドと同じアドレス空間で動かした。フォ
ルトを起したスレッドの状態は調べず、変更もしないので、例外は出続ける。
MK40, MK32, Mach2.5に対して、この二つのテストを大量に反復した平均結果を
表3に示した。

RPC性能の向上

MK32のRPC経路はMach 2.5に比較して既にかなり最適化されていたので、向上の
余地は少ししかなかった。プロセス形態(スレッド毎にスタックをもつ)だが、
MK32はRPC転送の間の一般的なスケジューラのコードを回避した。その代わりに
直接、送信スレッドから受信スレッドにコンテキストスイッチするようにした。
対照的に、Mach 2.5はメッセージを待ち行列に入れ、一般的なスケジューラが
次に走る受信スレッドを決定していた。

以前の最適化にもかかわらず、MK40のRPCは14%速い。その向上は主に、コンテ
キストスイッチをスタック渡しによって取って代えたことによる(2)。表4がス
タック渡しとコンテキストスイッチの命令、読み込み、書き込みの数の差であ
る。十分にスタック渡しはコンテキストスイッチより効果的である。

(2) MK40のToshiba 5200のRPC遅延は、バグによって少々増加している。
Toshiba 5200のトラップ処理はカーネルに入る時にユーザのレジスタを、別の
機種依存のデータ構造でなく、スタックに保存する。結果として、機種依存の
スタック渡しの手続きは現在のスレッドの状態をスタックからコピーし、新し
いスレッドのスタックにコピーしなくてはならない。この修正によって
Toshiba 5200の時間は50usecほど向上すると予想している。

継続の実行時の犠牲

Machで継続を使うことにに関連する実行時の犠牲が少しある。表4にあるように、
カーネルに入るのと出るのにかかる時間がMK40はMK32較べて少し長い。これは
継続と、そのアーキテクチャの呼び出し規約の相互作用によるものである。
MK32では、カーネルのシステムコールの入口ではどのレジスタもスタックに保
存する必要がない。呼び出し元退避(caller-saved)のレジスタは既にユーザ層
のスタックに保存されていて、そして呼び出し先退避(callee-saved)のレジス
タはカーネル層のスタックにコンパイラがシステムコールの必要に応じて保存
する。これは暗黙的にプロセス形態であることを想定していて、呼び出し先退
避のレジスタは、'return'の際にスタックから元に戻される。

継続を使って、そしてスタックが放棄されると、呼び出し先退避のレジスタで
あっても、返る際に元に戻されなくなってしまう。('return'は決っして起こら
ないからだ)結果として、カーネルの入口で全ての呼び出し先退避のレジスタを
補助的な機種依存のデータ構造に保持し、カーネルの出口ではこれらを元に戻
さないといけなくなった。DS3100の例では、9つの呼び出し先退避のレジスタが
あり、表4の追加の犠牲になる。例外と割込みに関しては、カーネルの入口では
呼び出し先退避でなくとも、必ず全てのレジスタを(退避しなくてはならない。
これはMK32でも同じように必要である。なので呼び出し先退避のレジスタを保
存することの相対的な犠牲は減っている。

例外処理の向上

表3に示すように、例外処理はMK40は2,3倍MK32に較べて速い。RPCと違い、
MK32では例外処理は最適化されていなかった。結果としてMK40の例外処理は継
続の一番良い状況を示した。そして、OSのカーネルで一般的な枠組のように継
続を使う重要な点も示している。高速だが可搬性のあるアドレス空間をまたぐ
RPC構造にから、制御移行の一般的な枠組みを開発することになった。一度イン
ターフェースが決まれば、簡単にそれを例外処理の経路に適用することができ
た。3日程の作業で、例外処理の実行時の性能の向上が見れた。スタック放棄に
よる空間の削減も実感した。さらに、最適化は機種非依存に実装されているの
で、一度作業するだけである。カーネルの経路に継続を使う経験も同じである。
継続を性能に重大な経路に適用することができ、それは少ない努力の割に良い
結果をもたらしたと結論づけた。

3.4 継続に起因する空間の節約

継続によって効果的にカーネルのスタックをスレッド毎でなく、プロセッサ毎
の資源に変更できる。カーネルスレッドの数を24から43で変化する(我々がメー
ルを読む機械は通常100から200スレッドあるが)3つのテストプログラムのため
に、MK32では多くのカーネルタックがカーネル層スタックとしてある。MK40で
はカーネルスタックの数は平均で2.002である。99%以上の時間でたた二つのス
タックが使われる。一つは、現在走行中のスレッドのためで、もう一つは継続
とともにブロックしていない、内部のカーネルスレッドのためである。そのス
レッドは継続を使うには難しい制御の流れである。そのスタックは機械毎(プロ
セッサ毎ではない)の不変のオーバーヘッドを表現する。残りの0.002スタック
はいくつかの制御移行が継続を使わないことに起因する(表1の下の行を見よ)。
最悪の状況では、コンパイルテストとMS-DOSエミュレーションは3スタックを使
い、カーネル作成では6使う。しかし安定した状況では2カーネルスタックだけ
が使われる。

表5: DS3100におけるスレッド管理のオーバーヘッド(byte)

継続に起因する節約を評価する別の方法としては、それぞれのスレッドが消費
するカーネルメモリの平均を考察する。表5はDS3100上のMK32とMK40のスレッド
毎のデータ構造のサイズを示している。この機械では継続によって平均でスレッ
ドに使う量を85%削減している。Toshibaでは同程度の削減がある。

 カーネルスレッドによって要求される空間は機種依存と機種非依存の状態と、
スタックがある。MK40では機種非依存状態は継続(4バイトの関数ポインタ)と
28バイトのスクラッチ領域の空間の分、MK32より大きい。機種依存スレッド状
況は例えば、カーネルに突入した時のユーザレジスタ等を含む。MK32において
はスレッドの機種依存状態はそのスレッドの専用スタックに保存される。MK40
は専用のカーネルスタックを持たないので、機種依存状態は別のデータ構造に
保存される。

スタックによって消費される空間はスタックそれ自体(4KB)と、カーネルアドレ
ス空間のスタックを維持する仮想メモリシステムによって使われる全てのデー
タ構造を含む。MK32ではカーネルスタックはページ可能で、なので追加の116バ
イト(4)のVMデータ構造を必要とした。MK40ではカーネルスタックが少ないので、
スタックをページ可能とする必要がなく、VMシステムの空間を節約する。さら
にMK40はタックを物理メモリから割り合てできるアーキテクチャであれば、
TLBエントリの節約になる。(他の目的に使える)

(4) カーネルスタックがページ可能だとしても、それらのスタックがメモリに
残っているのに十分な頻度で走る。MK32での例では、90%のカーネルスタックは
ステムがページを別のメモリにしたとしてもメモリに残っていた。休眠してい
るスレッドのスタックが実際にページアウトされている時、追加的なスレッド
毎に220バイトのVMに関係するデータ構造が必要なので、ページアウトされたス
タックは336バイトを消費する。

4. 以前の最適化の継続による一般化


継続は他のOSに見つかる制御移行の最適化に機種非依存な枠組を提供する。例
として、Machの継続を基本にしたRPCと、軽量遠隔手続き呼び出し
(LRPC)[Bershad et al. 90]の制御移行の様子を比較することができる。LRPCは
アドレス空間をまたぐRPC一般に対しての高性能プロセス間通信として設計され
た。LRPCの一部は高性能で、それはスレッドがアドレス空間の境界を越えるこ
とができるということによっていた。呼び出し元のアドレス空間のスレドはカー
ネルにトラップされ、それはサーバのアドレス空間に入り、そこでサーバのコー
ドを即座に実行し始める。戻る時は呼び出し元のスレッドはサーバのアドレス
空間からカーネルにトラップして戻り、次に続くトラップの命令で呼び出し元
のアドレス空間に戻る。シングルスレッドやり方の一番の性能的な優位性は、
全ての作業はシングルスレッドのコンテキストで終了するため、スケジューリ
ングとメッセージの待ち行列がLRPCの経路からまったくなくすことができるこ
とだ。

Machの継続を基本としたRPCはLRPCのような性能的な優位性の多くを達成するこ
とができた。:待ち行列なし、スケジューリングなし、そしてカーネルスタック
を呼び出し元と呼び出し先で共有する。実際、カーネルのロックを通る制御の
流れは二つのシステムで似ている。: 制御は、あるアドレス空間からカーネル
の手続きに入り、そして同じ手続きをもう一方にもして、出る。さらに、継続
を基本にしたRPCはクライアントとサーバの論理的な分離も支える。スレッドは
それらのアドレス空間の中で固定されたままで、スレッドがアドレス空間の間
を移動する時に起る保護、デバッグ、ごみ集めの問題の多くを取り除いた。
[Bershad 90]

継続の自然な拡張によって、完全にLRPC転送規約を真似することができた。
Machのスレッドがカーネルにトラップされる時、このトラップが起きたユーザ
層のコンテキストに制御を戻すための継続を作成する。IPCインターフェースを
スレッドがシステムコールから返るためのユーザ層の継続を上書きできるよう
にする拡張する実験をしている(5)。この拡張はサーバスレッドがレジスタを退
避/復旧する手間を取り除き、サーバスレッドはRPC要求の待ちでブロックして
いる間、ユーザ層のスタックを放棄することが可能になる。

カーネルの外部に戻る時の継続を一つではなくカーネルが入った時に活性であっ
た継続のどれかに戻ることができるようにすることで、継続は制御移行の機構
を豊富に集めたものをを一般的なやり方として実装することに使える。例えば、
上への呼びだし(upcall)はx-kernel[Hutchinson et al.89]に必要であり、
Scheduler Activations[ANderson et al. 91]は、基本「ユーザ層に戻る」継続
のブロックしたスレッドのプールをカーネルにとっておくことで実装できる。
上への呼びだしを実行するため、基本の継続はユーザ層の特定したアドレスへ
とカーネルの外に制御を移す継続によって取り替えられる。非同期I/O [Levy
& Eckhouse 89]は似たように作用する。非同期I/Oをスケジューリングすると、
スレッドはI/Oが完了した時に呼ばれる継続をカーネルに、提供する。

(5)この拡張はMachのメインリリースの一部ではない。

5 関連する研究

言語のコミュニティは20年ほど継続についての研究をしてきた。Wardは継続を
μ計算よばれるメッセージの受け渡しの代数の基本要素として定義した[Ward
& Halstead 80]。そして、全ての制御の移行はその代数を使って表現できるこ
とを示した。並行実行と'first-class'の継続をサポートする関数型言語は後者
を使って前者を成功裏に実装した[Wand 80,Haynes & Friedman 84, Cooper &
Morrisett 90]。これらの試みは同じアドレス空間のユーザ層どうしのコンテキ
スト間の制御の移行に集中している。関数型言語はしばしば 関数呼び出しのス
タックを実装するのに、非連続なデータ構造を使う。そしてスタックを放棄す
る能率を部分的に減らす。(カーネルスレッドの放棄できる状態の多くの部分は
活動中の一番下のコールフレームの上の使われていないスタック領域である)
さらに、多くの関数型言語は関数オブジェクトが同一であることの評価を許し
ていないので、継続認識をやりにくくしている。Lampson[Lampson et al. 74]
は初期のMesa言語[Geschke et al.77]に対する、継続を基本にした一般的な制
御移行のインターフェースをに書いた。

とても制限されたLampsonのインターフェースが、後にTopaz[Schroeder &
Burrows 90]のアドレス空間をまたぐRPCの実装として現れた。TopazはDEC SRC
の実験的なマルチプロセッサワークステーション[Thacker et al 88]、
Fireflyのために設計されたOSである。そのインターフェースはアセンブリ言語
で実装され、スタック受け渡しはするが、継続認識を使わず、共有スタックも
使わない。(SRCのRPCは高度に最適化されていて、全てはレジスタに保存される
ので、スタックには重要なコンテキストない) Topazは、カーネルスレッドがブ
ロックする時、それが再スケジューリングされた時に即座にユーザ層で実行さ
れる場合にはスタックを放棄することを可能にしていた。Topazはセマフォと条
件変数をカーネルで実装していたので、これはユーザ層のイベントでブロック
するスレッドに重要な最適化である。この二つの最適化にもかかわらず、
Topazのカーネルでは、スレッドがプロセス形態のままスタックを持ったままブ
ロックする場面が多くあった。DEC SRCの5プロセッサ、96MBのFireflyでの最近
の計測では、886個のカーネルスレッドが、212個のカーネルスレッドを使用し
ている。カーネルの内部スレッド(28)、完了待ち(106)、ネットワークパッケッ
ト待ち(20)、例外処理の待ち(38)である。継続によってFireflyのアドレス空間
をまたぐRPCは向上しないと思うが、多数のカーネルスタックによって消費され
る、バス、キャッシュ、メモリは軽減されるだろう。例えばMachでは886の似た
ようなブロックしているカーネルスレッドがあったとしても、6スタックしか必
要としないだろう。Fireflyの5つのプロセッサそれぞれのと、特別なカーネル
スレッドのだ。

QuickSilver[Haskin et al.88]、V[Ceriton 88]、MS-DOS[Duncan 86]のような、
割込み形態で実装されているOSは継続と等価なものをそれだけで使う。例えば
Vカーネルでは、"finish_up"関数をスレッドの記述子に結びつけ、それがブロッ
ク後に再開するスレッドの算定を可能にしている。しかしながら、これらのシ
ステムでは、プロセス形態を安全網として使うことができないので、カーネル
内部の構造が複雑になってしまっている。例えば、カーネルの中で実行する場
合ページフォルトは一般的に許されない。そして、マルチプロセッサに必要な
カーネル層の単純なロックですら難しい[Cheriton 91]。

継続認識を一般的な最適化技法として使用、あるいは、ユーザ-カーネル境界の
行き来をユーザ層のアップリケーションによって作用されることができる継続
を基本とした制御移行として扱うようなプロセス形態と割込み形態を組み合わ
せたシステムは他に見つからなかった。

6 将来の研究と結論

Machにおける継続の研究は進行中である。目下、ユーザ層のスレッドパッケー
ジであるC-Threadsで継続を使う実験中だ。ユーザ層のスレッドで継続が使用で
きるようにして、スタックを放棄できるようにし、もし可能であれば継続認識
をするようにするつもりである。ユーザ層で自身でスケジュールし同期をする
ようなアプリケーションには、継続によってその多数のユーザ層のスレッドに
よる空間とオーバーヘッドの時間を軽減すると期待している。

当初、コンテキスト間の制御の移行の実装や記述をする機構としての継続の柔
軟性と力を認識していなかった。この研究の新規性は、継続を一般的なOSカー
ネルに適用できるようにしたことにある。継続を使って、可搬性のある新しい
最適化をすることができるようになり、他のOSにある、いくつかの最適化を一
つの抽象化を使って作り直すことができる。結果として、相当なシステム性能
の向上を図ることができた。

この論文で述べた方法論と技術は他のOSカーネルにも適用して、同じような結
果をもたらすと思う。Mach 3.0カーネルのソースを含む我々のシステムを
cs.cmu.eduの匿名ftpから手に入れて調べることを勧める。



コルーチン。

古くはModula-2,BCPLで提供されていた。BCPLで書かれたTripos オペーレティ
ングシステ(Richards他1979)はコルーチンの構造を持っていた。

コルーチンはそれぞれ局所記憶(スタック)をもつ
その状態を保ったまま実行を一時的に停止

コルーチンの生成、削除(未実装)

fiber_t fiber_create (fiber_t 親, uint8_t *スタック, size_t,
	 fiber_func_t 実行を開始するアドレス);
ここで返り値はこのコルーチンを再開するための識別子になる。
そしてコルーチン自体はその制御ブロックの中にその実行状態を記憶する。

struct fiber
{
  struct fiber_reg regs;// 16byte 実行状態の記憶(レジスタ)
  fiber_t parent;
  fiber_t continuation;
  int32_t id;
  uint8_t stack[0]; 実行状態の記憶(スタック)
} __attribute__((packed, aligned (4)));

この実装ではコルーチンの制御の移行はあらかじめ制御ブロックにあるparent、
及びcontinuationに限られる。親に戻る情報が必要なため、fiber_createでは
親のfiber_tが必要。

子同士の制御の移行はあらかじめ親からfiber_twistで指定される。
void fiber_twist (fiber_t, int/*# of child*/, ...);
可変長引数の順番に呼びだされるように、それぞれの制御ブロックを設定する。

スレッドにくらべての利点、弱点
 + 制御の移行のオーバーヘッドが少ない。
 + コルーチン間の移行は明示的なため(同時に走ることがない)、共有資源のロックが
いらない
 - スケジューリングの対象ではないため割り込みから制御を移行することはできない。

前回のパーサの例では、GPSからの割り込みが入ったら割り込みハンドラはリン
グバッファにデータを入れ、パーサがまた親に戻ってくるまではバッファは処
理されない。パーサの処理に時間がかかって、リングバッファがあふれたら処
理不能。

ここでコルーチンの制御に移行は継続(continuation)と呼ばれる。

UNIXではカーネルがユーザのシグナルハンドラを呼び出すのに使われる。ユー
ザのアドレス空間にして、呼び出さないといけない。中断されたプロセスの状
態も汚すわけにはいかないので、あらかじめシグナルスタックを用意してこの
状態で実行させる必要がある。



